<!DOCTYPE HTML><html lang=en class="sidebar-visible no-js light"><head><meta charset=UTF-8><title>Shell Scripting - Computing from the Command Line</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta name=description content="Linux command line and Scripting guide for beginner to intermediate users"><meta name=viewport content="width=device-width, initial-scale=1"><meta name=theme-color content=#ffffff><link rel=icon href=favicon.svg><link rel="shortcut icon"href=favicon.png><link rel=stylesheet href=css/variables.css><link rel=stylesheet href=css/general.css><link rel=stylesheet href=css/chrome.css><link rel=stylesheet href=FontAwesome/css/font-awesome.css><link rel=stylesheet href=fonts/fonts.css><link rel=stylesheet href=highlight.css><link rel=stylesheet href=tomorrow-night.css><link rel=stylesheet href=ayu-highlight.css><link rel=stylesheet href=style.css><body><script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script><script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script><script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script><script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script><nav id=sidebar class=sidebar aria-label="Table of contents"><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=preface.html>Preface</a><li class="chapter-item expanded"><a href=introduction.html><strong aria-hidden=true>1.</strong> Introduction</a><li class="chapter-item expanded"><a href=command-line-overview.html><strong aria-hidden=true>2.</strong> Command Line Overview</a><li class="chapter-item expanded"><a href=managing-files-directories.html><strong aria-hidden=true>3.</strong> Managing Files and Directories</a><li class="chapter-item expanded"><a href=working-with-files-and-directories.html><strong aria-hidden=true>4.</strong> Working with Files and Directories</a><li class="chapter-item expanded"><a href=text-processing.html><strong aria-hidden=true>5.</strong> Text Processing</a><li class="chapter-item expanded"><a href=shell.html><strong aria-hidden=true>6.</strong> Shell</a><li class="chapter-item expanded"><a href=shell-scripting.html class=active><strong aria-hidden=true>7.</strong> Shell Scripting</a><li class="chapter-item expanded"><a href=shell-customization.html><strong aria-hidden=true>8.</strong> Shell Customization</a></li><br><hr><li class="chapter-item expanded"><i id=git-repository-button class="fa fa-github"></i><a href=https://github.com/learnbyexample/cli-computing>   Source code</a><li class="chapter-item expanded"><i id=home-button class="fa fa-home"></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i id=book-button class="fa fa-book"></i><a href=https://learnbyexample.github.io/books/>   My Books</a><li class="chapter-item expanded"><i id=mail-button class="fa fa-envelope"></i><a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>   learnbyexample weekly</a></ol></div><div id=sidebar-resize-handle class=sidebar-resize-handle></div></nav><div id=page-wrapper class=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div id=menu-bar class="menu-bar sticky bordered"><div class=left-buttons><button id=sidebar-toggle class=icon-button type=button title="Toggle Table of Contents"aria-label="Toggle Table of Contents"aria-controls=sidebar><i class="fa fa-bars"></i></button><button id=theme-toggle class=icon-button type=button title="Change theme"aria-label="Change theme"aria-haspopup=true aria-expanded=false aria-controls=theme-list><i class="fa fa-paint-brush"></i></button><ul id=theme-list class=theme-popup aria-label=Themes role=menu><li role=none><button role=menuitem class=theme id=light>Light (default)</button><li role=none><button role=menuitem class=theme id=rust>Rust</button><li role=none><button role=menuitem class=theme id=coal>Coal</button><li role=none><button role=menuitem class=theme id=navy>Navy</button><li role=none><button role=menuitem class=theme id=ayu>Ayu</button></ul><button id=search-toggle class=icon-button type=button title="Search. (Shortkey: s)"aria-label="Toggle Searchbar"aria-expanded=false aria-keyshortcuts=S aria-controls=searchbar><i class="fa fa-search"></i></button></div><h1 class=menu-title>Computing from the Command Line</h1><div class=right-buttons><a href=https://learnbyexample.github.io title=Blog aria-label=Blog> <i id=home-button class="fa fa-home"></i> </a><a href=https://github.com/learnbyexample/cli-computing title="Git repository"aria-label="Git repository"> <i id=git-repository-button class="fa fa-github"></i> </a></div></div><div id=search-wrapper class=hidden><form id=searchbar-outer class=searchbar-outer><input type=search id=searchbar name=searchbar placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header></form><div id=searchresults-outer class="searchresults-outer hidden"><div id=searchresults-header class=searchresults-header></div><ul id=searchresults></ul></div></div><script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script><div id=content class=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=shell-scripting><a class=header href=#shell-scripting>Shell Scripting</a></h1><p>This chapter will cover basic usage of <code>bash</code> for scripting purposes. You'll learn about declaring variables, control structures, working with arguments passed to a script, getting user input and so on.<h2 id=need-for-scripting><a class=header href=#need-for-scripting>Need for scripting</a></h2><p>From <a href=https://en.wikipedia.org/wiki/Scripting_language>wikipedia: Scripting language</a>:<blockquote><p>A scripting language or script language is a programming language for a runtime system that automates the execution of tasks that would otherwise be performed individually by a human operator. Scripting languages are usually interpreted at runtime rather than compiled.</blockquote><blockquote><p>Typical scripting languages are intended to be very fast to learn and write in, either as short source code files or interactively in a read–eval–print loop (REPL, language shell). This generally implies relatively simple syntax and semantics; typically a "script" (code written in the scripting language) is executed from start to finish, as a "script", with no explicit entry point.</blockquote><p>From <a href=https://en.wikipedia.org/wiki/Shell_script>wikipedia: Shell script</a>:<blockquote><p>A shell script is a computer program designed to be run by the Unix shell, a command-line interpreter. The various dialects of shell scripts are considered to be scripting languages. Typical operations performed by shell scripts include file manipulation, program execution, and printing text. A script which sets up the environment, runs the program, and does any necessary cleanup or logging, is called a wrapper.</blockquote><p>See also <a href=https://stackoverflow.com/q/17253545/4082052>Difference between scripting and programming languages</a><h2 id=executable-script><a class=header href=#executable-script>Executable script</a></h2><p>There are several ways you can put code in a file and execute the script. This section shows an example of creating an executable script. Consider this sample script saved in a file named <code>hello.sh</code>:<pre><code class=language-bash>#!/bin/bash

echo "Hello $USER"
echo "Today is $(date -u +%A)"
echo 'Have a nice day'
</code></pre><p>The first line in the above script has two parts:<ul><li><code>/bin/bash</code> is the path of <code>bash</code> interpreter (you can use <code>type -a bash</code> to get the path)<li><code>#!</code> is known as <a href=https://en.wikipedia.org/wiki/Shebang_(Unix)>shebang or hashbang</a> which directs the program loader to use the interpreter path provided <ul><li>See also <a href=https://stackoverflow.com/q/21612980>stackoverflow: comparison between #!/usr/bin/env and #!/bin/bash?</a><li>The <code>#</code> character starts a comment, <code>#!</code> is only special at the start of the script</ul></ul><p>Here's how you can make the file as executable and run it:<pre><code class=language-bash>$ chmod +x hello.sh

$ ./hello_world.sh 
Hello learnbyexample
Today is Wednesday
Have a nice day
</code></pre><blockquote><p><img src=images/info.svg alt=info> <code>.sh</code> is typically used as the file extension for shell scripts.</blockquote><h2 id=passing-file-argument-to-bash><a class=header href=#passing-file-argument-to-bash>Passing file argument to bash</a></h2><p>You can also pass a regular file as a file argument to <code>bash</code> for execution without having to use the shebang.<pre><code class=language-bash>$ cat greeting.sh
echo 'hello'
echo 'have a nice day'

$ bash greeting.sh
hello
have a nice day
</code></pre><h2 id=sourcing-script><a class=header href=#sourcing-script>Sourcing script</a></h2><p>Yet another way to execute a script is to <em>source</em> it using the <code>.</code> or <code>source</code> builtin command. A major difference from the previous methods is that the script is executed in the current shell environment context instead of a sub-shell. A common use case is sourcing <code>~/.bashrc</code> and alias/functions (if they are saved in a separate file).<p>Here's an example:<pre><code class=language-bash>$ cat prev_cmd.sh
prev=$(fc -ln -2 | sed 's/^\s*//;q')
echo "$prev"

# 'echo' here is just a sample command
$ echo 'hello'
hello
# sourcing the script correctly gives the previous command
$ source prev_cmd.sh
echo 'hello'

$ echo 'hello'
hello
# no output when the script is executed in a sub-shell
$ bash prev_cmd.sh
</code></pre><h2 id=comments><a class=header href=#comments>Comments</a></h2><p>Single line comments can be inserted after the <code>#</code> character, either at the start of a line or after an instruction.<blockquote><p><img src=images/info.svg alt=info> See also <a href=https://unix.stackexchange.com/q/37411/109046>Multiline comments</a>.</blockquote><h2 id=quoting-mechanisms><a class=header href=#quoting-mechanisms>Quoting mechanisms</a></h2><p>From <a href=https://www.gnu.org/software/bash/manual/bash.html#Quoting>bash manual</a>:<blockquote><p><strong>Escape Character</strong><p>A non-quoted backslash <code>\</code> is the Bash escape character. It preserves the literal value of the next character that follows, with the exception of newline.</blockquote><blockquote><p><strong>Single Quotes</strong><p>Enclosing characters in single quotes (<code>'</code>) preserves the literal value of each character within the quotes. A single quote may not occur between single quotes, even when preceded by a backslash.</blockquote><blockquote><p><strong>Double Quotes</strong><p>Enclosing characters in double quotes (<code>"</code>) preserves the literal value of all characters within the quotes, with the exception of <code>$</code>, <code>`</code>, <code>\</code>, and, when history expansion is enabled, <code>!</code>.</blockquote><blockquote><p><strong>ANSI-C Quoting</strong><p>Words of the form $'string' are treated specially. The word expands to string, with backslash-escaped characters replaced as specified by the ANSI C standard.</blockquote><h2 id=variables-and-arrays><a class=header href=#variables-and-arrays>Variables and Arrays</a></h2><p>Here's a simple example of assigning a variable and accessing its value:<pre><code class=language-bash>$ name='learnbyexample'

$ echo "$name"
learnbyexample
</code></pre><p>As seen above, you need to use the <code>$</code> prefix while accessing the value stored in a variable. You can use <code>${variable}</code> syntax to distinguish between the variable and other parts of the string. Using appropriate quotes is recommended, unless otherwise needed.<p>Assigning variables is one of the most common source for errors. Unlike most programming languages, spaces are <em>not</em> allowed around the <code>=</code> sign. That is because space is a shell metacharacter. Another common issue is using quotes (or not) around the value. Here are some examples:<pre><code class=language-bash>$ num = 42
num: command not found

$ greeting=hello world
world: command not found
$ greeting='hello world'
$ echo "$greeting"
hello world

# using quotes is NOT desirable here
$ dir_path=~/reports
$ echo "$dir_path"
/home/learnbyexample/reports
$ dir_path='~/reports'
$ echo "$dir_path"
~/reports
</code></pre><p>From <a href=https://www.gnu.org/software/bash/manual/bash.html#Arrays>bash manual: Arrays</a>:<blockquote><p>Bash provides one-dimensional indexed and associative array variables. Any variable may be used as an indexed array; the declare builtin will explicitly declare an array. There is no maximum limit on the size of an array, nor any requirement that members be indexed or assigned contiguously. Indexed arrays are referenced using integers and are zero-based; associative arrays use arbitrary strings.</blockquote><p>Here are some examples:<pre><code class=language-bash>$ fruits=('apple' 'fig' 'mango')

# first element
$ echo "${fruits[0]}"
apple

# last element
$ echo "${fruits[-1]}"
mango

# all elements
# example with for loop will be discussed later on
$ echo "${fruits[@]}"
apple fig mango
$ printf '%s\n' "${fruits[@]}"
apple
fig
mango
</code></pre><blockquote><p><img src=images/info.svg alt=info> See <a href=https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameters>bash manual: Shell Parameters</a> for <code>declare</code> builtin command and other details.</blockquote><h2 id=parameter-expansion><a class=header href=#parameter-expansion>Parameter Expansion</a></h2><p>Bash provides several useful ways to extract and modify contents of a variable (including arrays). Some of these features will be discussed in this section.<p>Substring extraction using <code>${parameter:offset}</code> syntax to get all characters from the given index:<pre><code class=language-bash>$ city='Lucknow'

# all characters from index 4 onwards
$ echo "${city:4}"
now

# last two characters
# space before the negative sign is compulsory here,
# since ${parameter:-word} is a different feature
$ echo "${city: -2}"
ow
</code></pre><p>Substring extraction using <code>${parameter:offset:length}</code> syntax to get specific number of characters from the given index:<pre><code class=language-bash>$ city='Lucknow'

# 4 characters starting from index 0
$ echo "${city:0:4}"
Luck

# 2 characters starting from index -4 (4th character from the end)
$ echo "${city: -4:2}"
kn
</code></pre><p>When applied to arrays, substring extraction will give you those elements:<pre><code class=language-bash>$ fruits=('apple' 'fig' 'mango')

# all elements from index 1
$ echo "${fruits[@]:1}"
fig mango
</code></pre><p><code>${#parameter}</code> will give you the length of the string and <code>${#array[@]}</code> will give you the number of elements in the array:<pre><code class=language-bash>$ city='Lucknow'
$ echo "${#city}"
7

$ fruits=('apple' 'fig' 'mango')
$ echo "${#fruits[@]}"
3
</code></pre><p><code>${parameter#glob}</code> will remove the shortest match from the start of the string. <code>${parameter##glob}</code> will remove the longest match from the start of the string. Here are some examples:<pre><code class=language-bash>$ s='this is his life history'

# shortest match is deleted
$ echo "${s#*is}"
 is his life history

# longest match is deleted
$ echo "${s##*is}"
tory

# for arrays, the processing is applied to each element
$ fruits=('apple' 'fig' 'mango')
$ echo "${fruits[@]#*[aeiou]}"
pple g ngo
</code></pre><p><code>${parameter%glob}</code> will remove the shortest match from the end of the string. <code>${parameter%%glob}</code> will remove the longest match from the end of the string. Here are some examples:<pre><code class=language-bash>$ s='this is his life history'

$ echo "${s%is*}"
this is his life h
$ echo "${s%%is*}"
th

$ fruits=('apple' 'fig' 'mango')
$ echo "${fruits[@]%[aeiou]*}"
appl f mang
</code></pre><p><code>${parameter/glob/string}</code> will replace the first matching occurrence with the given replacement string and <code>${parameter//glob/string}</code> will replace all the matching occurrences. You can leave out the <code>/string</code> portion when you want to delete the matching occurrences. The <code>glob</code> will match the longest portion, similar to greedy behavior in regular expressions. Here are some examples:<pre><code class=language-bash>$ s='this is a sample string'

# first occurrence of 'is' is replaced with '123'
$ echo "${s/is/123}"
th123 is a sample string
# all occurrences of 'is' are replaced with '123'
$ echo "${s//is/123}"
th123 123 a sample string

# matches from first 'is' to last 's' in the input
$ echo "${s/is*s/ X }"
th X tring

# deletes first occurrence of 'is'
$ echo "${s/is}"
th is a sample string
# deletes all occurrences of 'is'
$ echo "${s//is}"
th  a sample string
</code></pre><p><code>${parameter/#glob/string}</code> will match only at the start of the string and <code>${parameter/%glob/string}</code> will match only at the end of the string.<pre><code class=language-bash>$ s='spare'

# remove only from the start of the string
$ echo "${s/#sp}"
are
$ echo "${s/#par}"
spare

# remove only from the end of the string
$ echo "${s/%re}"
spa
$ echo "${s/%par}"
spare
</code></pre><p><code>${parameter^glob}</code> changes the first character to uppercase if matched by the glob. <code>${parameter^^glob}</code> changes all the matching characters to uppercase. You should provide a glob of one character length only, either a literal alphabet or a character class. If the glob is omitted, entire parameter will be matched.<pre><code class=language-bash>$ fruit='apple'

$ echo "${fruit^}"
Apple
$ echo "${fruit^^}"
APPLE

$ echo "${fruit^^[g-z]}"
aPPLe
$ echo "${fruit^^[a-ej-m]}"
AppLE

# the glob matches 'ap' at the start
# but this won't work since multiple characters are specified
$ echo "${fruit^^[a-e][f-z]}"
apple
</code></pre><p>To change the characters to lowercase, use <code>,</code> and <code>,,</code> as shown below:<pre><code class=language-bash>$ fruit='APPLE'

$ echo "${fruit,}"
aPPLE
$ echo "${fruit,,}"
apple

$ echo "${fruit,,[G-Z]}"
ApplE
</code></pre><p>To swap case, use <code>~</code> and <code>~~</code> as shown below:<pre><code class=language-bash>$ fruit='aPPle'

$ echo "${fruit~}"
APPle
$ echo "${fruit~~}"
AppLE

$ echo "${fruit~~[g-zG-Z]}"
appLe
</code></pre><blockquote><p><img src=images/info.svg alt=info> See <a href=https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion>bash manual: Shell Parameter Expansion</a> for more details and other types of expansions.</blockquote><h2 id=command-line-arguments><a class=header href=#command-line-arguments>Command Line Arguments</a></h2><p>Command line arguments passed to a script are saved in positional variables starting with <code>1</code>, <code>2</code>, <code>3</code> etc. <code>0</code> contains the name of the shell or shell script. <code>@</code> contains all the positional arguments starting from <code>1</code>. Use <code>#</code> to get the number of positional arguments.<p>Here's an example script that accepts two positional arguments:<pre><code class=language-bash>$ cat command_line_arguments.sh
echo "No. of lines in '$1' is $(wc -l < "$1")"
echo "No. of lines in '$2' is $(wc -l < "$2")"

$ bash command_line_arguments.sh hello.sh test\ file.txt 
No. of lines in 'hello.sh' is 9
No. of lines in 'test file.txt' is 5
</code></pre><p><strong>Further Reading</strong><ul><li><a href=https://unix.stackexchange.com/q/131766/109046>unix.stackexchange: Why does my shell script choke on whitespace or other special characters?</a><li><a href=https://stackoverflow.com/q/5163144/4082052>stackoverflow: bash special parameters reference</a></ul><h2 id=conditional-expressions><a class=header href=#conditional-expressions>Conditional Expressions</a></h2><p>You can test a condition within <code>[[</code> and <code>]]</code> to get a success (<code>0</code>) or failure (<code>1</code> or higher) exit status and take action accordingly. Bash provides several options and operators that you can use. Space is required after <code>[[</code> and before <code>]]</code> for this compound command to function.<h3 id=options><a class=header href=#options>Options</a></h3><p>Here is an example that checks if the given path is valid:<pre><code class=language-bash>$ [[ -e hello.sh ]] && echo 'file exists' || echo 'not found'
file exists

$ [[ -e xyz.txt ]] && echo 'file exists' || echo 'not found'
not found

# exit status
$ [[ -e hello.sh ]] ; echo $?
0
$ [[ -e xyz.txt ]] ; echo $?
1
</code></pre><p>The <code>-e</code> option checks the given path argument, which evaluates to true if it exists. The <code>&&</code> and <code>||</code> are control operators that executes the command that follows only if the earlier command evaluates to true and false respectively. You can also use <code>if-else</code> control structure for the above example (will be discussed later).<p>You can use <code>-d</code> and <code>-f</code> to check if the path is a valid directory and file respectively. The <code>-s</code> option checks if file exists and its size is greater than zero. <code>-x</code> option checks if file exists and is executable. See <a href=https://www.gnu.org/software/bash/manual/bash.html#Bash-Conditional-Expressions>bash manual: Conditional Expressions</a> for a complete list of such options.<p>Add a <code>!</code> prefix to negate the condition, <code>[[ ! -e xyz.txt ]]</code> for example.<h3 id=string-comparison><a class=header href=#string-comparison>String comparison</a></h3><ul><li><code>s1 = s2</code> or <code>s1 == s2</code> checks if two strings are equal <ul><li>unquoted portions of <code>s2</code> will be treated as a wildcard while testing against <code>s1</code><li><code>extglob</code> would be considered as enabled for comparison purposes</ul><li><code>s1 != s2</code> checks if strings are <em>not</em> equal <ul><li>unquoted portions of <code>s2</code> will be treated as a wildcard while testing against <code>s1</code><li><code>extglob</code> would be considered as enabled for comparison purposes</ul><li><code>s1 < s2</code> checks if <code>s1</code> sorts before <code>s2</code> lexicographically<li><code>s1 > s2</code> checks if <code>s1</code> sorts after <code>s2</code> lexicographically<li><code>s1 =~ s2</code> checks if <code>s1</code> matches the POSIX extended regular expression provided by <code>s2</code> <ul><li>exit status will be <code>2</code> if <code>s2</code> is not a valid regexp</ul></ul><p>Here are some examples for equal and not-equal comparisons:<pre><code class=language-bash>$ fruit='apple'
$ [[ $fruit == 'apple' ]] && echo 'true' || echo 'false'
true
$ [[ $fruit == 'banana' ]] && echo 'true' || echo 'false'
false

$ [[ hello == h* ]] && echo 'true' || echo 'false'
true
$ [[ hello == 'h*' ]] && echo 'true' || echo 'false'
false

$ [[ hello != *a* ]] && echo 'true' || echo 'false'
true
$ [[ hello != *e* ]] && echo 'true' || echo 'false'
false
</code></pre><p>Here are some examples for greater-than and less-than comparisons:<pre><code class=language-bash>$ [[ apple < banana ]] && echo 'true' || echo 'false'
true
$ [[ par < part ]] && echo 'true' || echo 'false'
true

$ [[ mango > banana ]] && echo 'true' || echo 'false'
true
$ [[ sun > moon && fig < papaya ]] && echo 'true' || echo 'false'
true

# don't use this to compare numbers!
$ [[ 20 > 3 ]] && echo 'true' || echo 'false'
false
</code></pre><p>Here are some examples for regexp comparison. You can use the special array <code>BASH_REMATCH</code> to retrieve specific portions of the string that was matched.<pre><code class=language-bash>$ fruit='apple'
$ [[ $fruit =~ ^a ]] && echo 'true' || echo 'false'
true
$ [[ $fruit =~ ^b ]] && echo 'true' || echo 'false'
false

$ [[ $fruit =~ a.. ]] && echo "${BASH_REMATCH[0]}"
app
$ [[ $fruit =~ a(..) ]] && echo "${BASH_REMATCH[1]}"
pp
</code></pre><h3 id=numeric-comparison><a class=header href=#numeric-comparison>Numeric comparison</a></h3><ul><li><code>n1 -eq n2</code> checks if two numbers are equal<li><code>n1 -ne n2</code> checks if two numbers are <em>not</em> equal<li><code>n1 -gt n2</code> checks if <code>n1</code> is greater than <code>n2</code><li><code>n1 -ge n2</code> checks if <code>n1</code> is greater than or equal to <code>n2</code><li><code>n1 -lt n2</code> checks if <code>n1</code> is less than <code>n2</code><li><code>n1 -le n2</code> checks if <code>n1</code> is less than or equal to <code>n2</code></ul><p>Only positive or negative integer comparisons are supported by these operators.<pre><code class=language-bash>$ [[ 20 -gt 3 ]] && echo 'true' || echo 'false'
true

$ n1='42'
$ n2='25'
$ [[ $n1 -gt 30 && $n2 -lt 12 ]] && echo 'true' || echo 'false'
false
</code></pre><p>Numeric arithmetic operations and comparisons can be performed within <code>((</code> and <code>))</code> compound command. Here are some sample comparisons:<pre><code class=language-bash>$ (( 20 > 3 )) && echo 'true' || echo 'false'

$ n1='42'
$ n2='25'
$ (( n1 > 30 && n2 < 12 )) && echo 'true' || echo 'false'
false
</code></pre><blockquote><p><img src=images/info.svg alt=info> See <a href=https://www.gnu.org/software/bash/manual/bash.html#Shell-Arithmetic>bash manual: Shell Arithmetic</a> for more details.</blockquote><h2 id=accepting-user-input-interactively><a class=header href=#accepting-user-input-interactively>Accepting user input interactively</a></h2><p>You can use the <code>read</code> builtin command to accept input from the user interactively. The <code>-p</code> option will allow you to specify a user prompt. Here is an example of getting two arguments from the user:<pre><code class=language-bash>$ cat user_input.sh
read -p 'Enter two integers separated by spaces: ' num1 num2
sum=$(( num1 + num2 ))
echo "$num1 + $num2 = $sum"

$ bash user_input.sh
Enter two integers separated by spaces: -2 42
-2 + 42 = 40
</code></pre><blockquote><p><img src=images/info.svg alt=info> See <code>help read</code> or <a href=https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins>bash manual: Builtins</a> for more details.</blockquote><h2 id=if-then-else><a class=header href=#if-then-else>if then else</a></h2><p>The keywords needed to construct an <code>if</code> control structure are <code>if</code>, <code>then</code>, <code>fi</code> and optionally <code>else</code> and <code>elif</code>. You can use compound commands like <code>[[</code> and <code>((</code> to provide the test condition. You can also directly use a command's exit status. Here's an example script:<pre><code class=language-bash>$ cat if_then_else.sh
if (( $# != 1 )) ; then
    echo 'Error! One file argument expected.' 1>&2
    exit 1
else
    if [[ ! -f $1 ]] ; then
        echo "Error! '$1' is not a valid file" 1>&2
        exit 1
    else
        echo "No. of lines in '$1' is $(wc -l < "$1")"
    fi
fi
</code></pre><p><code>1>&2</code> is used in the above script to print error messages to the <code>stderr</code> stream. Sample script invocations are shown below:<pre><code class=language-bash>$ bash if_then_else.sh
Error! One file argument expected.
$ echo $?
1

$ bash if_then_else.sh xyz.txt
Error! 'xyz.txt' is not a valid file
$ echo $?
1

$ bash if_then_else.sh hello.sh
No. of lines in 'hello.sh' is 5
$ echo $?
0
</code></pre><p>Sometimes you just need to know if the intended command operation was successful or not and then take an action depending on the outcome. In such cases, you can provide the command directly after the <code>if</code> keyword. Note that <code>stdout</code> and <code>stderr</code> of the command will still be active unless redirected or suppressed using appropriate options.<p>For example, the <code>grep</code> command supports <code>-q</code> option to suppress normal output. Here's a script using that feature:<pre><code class=language-bash>$ cat search.sh 
read -p 'Enter a search pattern: ' search

if grep -q "$search" hello.sh ; then
    echo "match found"
else
    echo "match not found"
fi
</code></pre><p>Sample invocations for the above script:<pre><code class=language-bash>$ bash search.sh
Enter a search pattern: echo
match found

$ bash search.sh
Enter a search pattern: xyz
match not found
</code></pre><h2 id=for-loop><a class=header href=#for-loop>for loop</a></h2><p>To construct a <code>for</code> loop, you'll need the <code>for</code>, <code>do</code> and <code>done</code> keywords. Here are some examples:<pre><code class=language-bash># iterate over numbers generated using brace expansion
$ for num in {2..4}; do echo "$num"; done
2
3
4

# iterate over files matched using wildcards
# echo is used here for dry run testing
$ for file in [gh]*.sh; do echo mv "$file" "$file.bkp"; done
mv greeting.sh greeting.sh.bkp
mv hello.sh hello.sh.bkp
</code></pre><p>As seen in the above examples, the space separated arguments provided after the <code>in</code> keyword are automatically assigned to the variable provided after the <code>for</code> keyword for each iteration.<p>Here's a modified example of the last example that accepts user provided command line arguments:<pre><code class=language-bash># 'in "$@"' portion can be skipped, since that's the default
$ cat for_loop.sh
for file in "$@"; do 
    echo mv "$file" "$file.bkp"
done

$ bash for_loop.sh [gh]*.sh
mv greeting.sh greeting.sh.bkp
mv hello.sh hello.sh.bkp

$ bash for_loop.sh report.log ip.txt fruits.txt
mv report.log report.log.bkp
mv ip.txt ip.txt.bkp
mv fruits.txt fruits.txt.bkp
</code></pre><p>Here's an example of iterating over an array:<pre><code class=language-bash>$ files=('report.log' 'pass_list.txt')
$ for f in "${files[@]}"; do echo "$f"; done
report.log
pass_list.txt
</code></pre><blockquote><p><img src=images/info.svg alt=info> You can use <code>continue</code> and <code>break</code> as loop control depending on specific conditions. See <a href=https://www.gnu.org/software/bash/manual/bash.html#Bourne-Shell-Builtins>bash manual: Bourne Shell Builtins</a> for more details.</blockquote><h2 id=while-loop><a class=header href=#while-loop>while loop</a></h2><p>Here's a simple <code>while</code> loop construct, you'll see a more practical example later.<pre><code class=language-bash>$ cat while_loop.sh
i="$1"
while (( i > 0 )) ; do
    echo "$i"
    (( i-- ))
done

$ bash while_loop.sh 3
3
2
1
</code></pre><h2 id=reading-a-file><a class=header href=#reading-a-file>Reading a file</a></h2><p>The <code>while</code> loop combined with the <code>read</code> builtin helps you to process the content of a file. Here's an example of reading input contents line by line:<pre><code class=language-bash>$ cat read_file_lines.sh
while IFS= read -r line; do
    # do something with each line
    echo "$line"
done < "$1"

$ bash read_file_lines.sh <(printf 'apple\nbanana\n')
apple
banana
</code></pre><p>The intention in the above script is to treat each input line literally. So, the <code>IFS</code> special variable is set to empty string to prevent stripping of leading and trailing whitespaces. The <code>-r</code> option to the <code>read</code> builtin allows <code>\</code> in input to be treated literally. Note that the input filename is accepted as the first command line argument and redirected as <code>stdin</code> to the <code>while</code> loop. You also need to make sure that the last line of input ends with a newline character, otherwise the last line won't be processed.<p>You can change <code>IFS</code> to split the input line into different fields and specify appropriate number of variables to the <code>read</code> builtin. Here's an example:<pre><code class=language-bash>$ cat read_file_fields.sh
while IFS=' : ' read -r field1 field2; do
    echo "$field2,$field1"
done < "$1"

$ bash read_file_fields.sh <(printf 'apple : 3\nfig : 100\n')
3,apple
100,fig
</code></pre><p>You can pass a number to the <code>-n</code> option for the <code>read</code> builtin to process the input that many characters at a time. Here's an example:<pre><code class=language-bash>$ while read -r -n2 c; do echo "$c"; done <<< '\word'
\w
or
d
</code></pre><h2 id=debugging><a class=header href=#debugging>Debugging</a></h2><p>You can use the following <code>bash</code> options for debugging purposes:<ul><li><code>-x</code> print commands and their arguments as they are executed<li><code>-v</code> verbose option, print shell input lines as they are read</ul><p>Here's an example with <code>bash -x</code> option:<pre><code class=language-bash>$ bash -x search.sh
+ read -p 'Enter a search pattern: ' search
Enter a search pattern: xyz
+ grep -q xyz hello.sh
+ echo 'match not found'
match not found
</code></pre><p>In the above illustration, the lines starting with <code>+</code> show the command being executed with expanded values if applicable (the <code>search</code> variable to <code>grep -q</code> for example). Multiple <code>+</code> will be used if there are multiple expansions. Here's how <code>bash -xv</code> would behave for the same script:<pre><code class=language-bash>$ bash -xv search.sh
read -p 'Enter a search pattern: ' search
+ read -p 'Enter a search pattern: ' search
Enter a search pattern: xyz

if grep -q "$search" hello.sh ; then
    echo "match found"
else
    echo "match not found"
fi
+ grep -q xyz hello.sh
+ echo 'match not found'
match not found
</code></pre><blockquote><p><img src=images/info.svg alt=info> You can also use <code>set -x</code> or <code>set -v</code> or <code>set -xv</code> from within the script to debug from a particular point onwards. You can turn off such debugging by using <code>+</code> instead of <code>-</code> for the <code>set</code> command.</blockquote><h2 id=shellcheck><a class=header href=#shellcheck>shellcheck</a></h2><p><a href=http://www.shellcheck.net/>shellcheck</a> is a static analysis tool that gives warnings and suggestions for scripts. You can use it online or install the tool for offline use. Given the various <code>bash</code> gotchas, this tool is helpful for both beginners and advanced users.<pre><code class=language-bash>$ cat bad_script.sh
#!/bin/bash

greeting = 'hello world'
echo "$greeting"
</code></pre><p>Here's how <code>shellcheck</code> reports the issue:<pre><code class=language-bash>$ shellcheck bad_script.sh

In bad_script.sh line 3:
greeting = 'hello world'
         ^-- SC1068: Don't put spaces around the = in assignments (or quote to make it literal).

For more information:
  https://www.shellcheck.net/wiki/SC1068 -- Don't put spaces around the = in ...
</code></pre><blockquote><p><img src=images/info.svg alt=info> Use the <code>-s</code> option (<code>-s bash</code> for example) if your script doesn't have a shebang.</blockquote><blockquote><p><img src=images/info.svg alt=info> Note that <code>shellcheck</code> will not catch all types of issues. And suggestions should not be blindly accepted without understanding if that makes sense in the given context.</blockquote><h2 id=resource-lists><a class=header href=#resource-lists>Resource lists</a></h2><p>Here are some more learning resources:<p><strong>Shell Scripting</strong><ul><li><a href=https://mywiki.wooledge.org/BashGuide>Bash Guide</a> — aspires to teach good practice techniques for using Bash, and writing simple scripts<li><a href=https://ryanstutorials.net/bash-scripting-tutorial/>Bash Scripting Tutorial</a> — solid foundation in how to write Bash scripts, to get the computer to do complex, repetitive tasks for you<li><a href=https://github.com/denysdovhan/bash-handbook>bash-handbook</a> — for those who want to learn Bash without diving in too deeply<li><a href=https://freebsdfrau.gitbook.io/serious-shell-programming/>Serious Shell Programming</a> — focuses on POSIX-compliant Bourne Shell for portability</ul><p><strong>Handy tools, tips and reference</strong><ul><li><a href=https://www.shellcheck.net/>shellcheck</a> — linting tool to avoid common mistakes and improve your script<li><a href=https://devmanual.gentoo.org/tools-reference/bash/index.html>Bash reference cheatsheet</a> — nicely formatted and explained well<li><a href=https://devhints.io/bash>Bash scripting cheatsheet</a> — quick reference to getting started with Bash scripting<li>Comprehensive lists on <code>mywiki.wooledge.org</code> website: <ul><li><a href=https://mywiki.wooledge.org/BashFAQ>Bash FAQ</a><li><a href=https://mywiki.wooledge.org/BashGuide/Practices>Bash Practices</a><li><a href=https://mywiki.wooledge.org/BashPitfalls>Bash Pitfalls</a></ul><li><a href=https://google.github.io/styleguide/shellguide.html>Google shell style guide</a><li>Reliability and robustness <ul><li><a href=https://github.com/anordal/shellharden/blob/master/how_to_do_things_safely_in_bash.md>safe ways to do things in bash</a><li><a href=https://robertmuth.blogspot.in/2012/08/better-bash-scripting-in-15-minutes.html>better scripting</a><li><a href=https://www.davidpashley.com/articles/writing-robust-shell-scripts/>robust scripting</a></ul></ul><p><strong>Specific topics</strong><ul><li><a href=https://ryanstutorials.net/bash-scripting-tutorial/bash-functions.php>functions</a><li>Reading file(s) <ul><li><a href=https://mywiki.wooledge.org/BashFAQ/001>Reading file</a><li><a href=https://unix.stackexchange.com/q/82541/109046>Loop through the lines of two files in parallel</a></ul><li><a href=https://mywiki.wooledge.org/BashGuide/Arrays>arrays</a><li><a href=https://unix.stackexchange.com/q/288886/109046>nameref</a> <ul><li>also see this <a href=https://mywiki.wooledge.org/BashFAQ/006>FAQ</a></ul><li>getopts <ul><li><a href=https://wiki.bash-hackers.org/howto/getopts_tutorial>getopts tutorial</a><li><a href=https://mywiki.wooledge.org/BashFAQ/035>handling command-line arguments</a><li><a href=https://stackoverflow.com/q/16483119/4082052>stackoverflow: getopts example</a></ul></ul></main><nav class=nav-wrapper aria-label="Page navigation"><a rel=prev href=shell.html class="mobile-nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=shell-customization.html class="mobile-nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav class=nav-wide-wrapper aria-label="Page navigation"><a rel=prev href=shell.html class="nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=shell-customization.html class="nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a></nav></div><script>
            window.playground_copyable = true;
        </script><script src=elasticlunr.min.js charset=utf-8></script><script src=mark.min.js charset=utf-8></script><script src=searcher.js charset=utf-8></script><script src=clipboard.min.js charset=utf-8></script><script src=highlight.js charset=utf-8></script><script src=book.js charset=utf-8></script><script src=sidebar.js></script>