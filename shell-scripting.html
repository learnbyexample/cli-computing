<!DOCTYPE HTML><html lang=en class="sidebar-visible no-js light"><head><meta charset=UTF-8><title>Shell Scripting - Computing from the Command Line</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta name=description content="Linux Command Line and Shell Scripting for beginner to intermediate level users"><meta name=viewport content="width=device-width, initial-scale=1"><meta name=theme-color content=#ffffff><meta property=og:title content="Computing from the Command Line"><meta property=og:type content=website><meta property=og:description content="Linux Command Line and Shell Scripting for beginner to intermediate level users"><meta property=og:url content=https://learnbyexample.github.io/cli-computing/><meta property=og:image content=https://learnbyexample.github.io/cli-computing/images/cli_computing_ls.png><meta property=og:image:width content=1280><meta property=og:image:height content=720><meta property=twitter:card content=summary_large_image><meta property=twitter:site content=@learn_byexample><link rel=icon href=favicon.svg><link rel="shortcut icon"href=favicon.png><link rel=stylesheet href=css/variables.css><link rel=stylesheet href=css/general.css><link rel=stylesheet href=css/chrome.css><link rel=stylesheet href=FontAwesome/css/font-awesome.css><link rel=stylesheet href=fonts/fonts.css><link rel=stylesheet href=highlight.css><link rel=stylesheet href=tomorrow-night.css><link rel=stylesheet href=ayu-highlight.css><link rel=stylesheet href=style.css><body><script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script><script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script><script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script><script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script><nav id=sidebar class=sidebar aria-label="Table of contents"><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=cover.html>Cover</a><li class="chapter-item expanded affix"><a href=buy.html>Buy PDF/EPUB versions</a><li class="chapter-item expanded affix"><a href=preface.html>Preface</a><li class="chapter-item expanded"><a href=introduction-setup.html><strong aria-hidden=true>1.</strong> Introduction and Setup</a><li class="chapter-item expanded"><a href=command-line-overview.html><strong aria-hidden=true>2.</strong> Command Line Overview</a><li class="chapter-item expanded"><a href=managing-files-directories.html><strong aria-hidden=true>3.</strong> Managing Files and Directories</a><li class="chapter-item expanded"><a href=shell-features.html><strong aria-hidden=true>4.</strong> Shell Features</a><li class="chapter-item expanded"><a href=viewing-part-or-whole-file-contents.html><strong aria-hidden=true>5.</strong> Viewing Part or Whole File Contents</a><li class="chapter-item expanded"><a href=searching-files-and-filenames.html><strong aria-hidden=true>6.</strong> Searching Files and Filenames</a><li class="chapter-item expanded"><a href=file-properties.html><strong aria-hidden=true>7.</strong> File Properties</a><li class="chapter-item expanded"><a href=managing-processes.html><strong aria-hidden=true>8.</strong> Managing Processes</a><li class="chapter-item expanded"><a href=multipurpose-text-processing-tools.html><strong aria-hidden=true>9.</strong> Multipurpose Text Processing Tools</a><li class="chapter-item expanded"><a href=sorting-stuff.html><strong aria-hidden=true>10.</strong> Sorting Stuff</a><li class="chapter-item expanded"><a href=comparing-files.html><strong aria-hidden=true>11.</strong> Comparing Files</a><li class="chapter-item expanded"><a href=assorted-text-processing-tools.html><strong aria-hidden=true>12.</strong> Assorted Text Processing Tools</a><li class="chapter-item expanded"><a href=shell-scripting.html class=active><strong aria-hidden=true>13.</strong> Shell Scripting</a><li class="chapter-item expanded"><a href=shell-customization.html><strong aria-hidden=true>14.</strong> Shell Customization</a></li><br><hr><li class="chapter-item expanded"><i id=git-repository-button class="fa fa-github"></i><a href=https://github.com/learnbyexample/cli-computing>   Source code</a><li class="chapter-item expanded"><i id=home-button class="fa fa-home"></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i id=book-button class="fa fa-book"></i><a href=https://learnbyexample.github.io/books/>   My Books</a><li class="chapter-item expanded"><i id=mail-button class="fa fa-envelope"></i><a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>   learnbyexample weekly</a><li class="chapter-item expanded"><i id=twitter-button class="fa fa-twitter"></i><a href=https://twitter.com/learn_byexample>   Twitter</a></ol></div><div id=sidebar-resize-handle class=sidebar-resize-handle></div></nav><div id=page-wrapper class=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div id=menu-bar class="menu-bar sticky bordered"><div class=left-buttons><button id=sidebar-toggle class=icon-button type=button title="Toggle Table of Contents"aria-label="Toggle Table of Contents"aria-controls=sidebar><i class="fa fa-bars"></i></button><button id=theme-toggle class=icon-button type=button title="Change theme"aria-label="Change theme"aria-haspopup=true aria-expanded=false aria-controls=theme-list><i class="fa fa-paint-brush"></i></button><ul id=theme-list class=theme-popup aria-label=Themes role=menu><li role=none><button role=menuitem class=theme id=light>Light (default)</button><li role=none><button role=menuitem class=theme id=rust>Rust</button><li role=none><button role=menuitem class=theme id=coal>Coal</button><li role=none><button role=menuitem class=theme id=navy>Navy</button><li role=none><button role=menuitem class=theme id=ayu>Ayu</button></ul><button id=search-toggle class=icon-button type=button title="Search. (Shortkey: s)"aria-label="Toggle Searchbar"aria-expanded=false aria-keyshortcuts=S aria-controls=searchbar><i class="fa fa-search"></i></button></div><h1 class=menu-title>Computing from the Command Line</h1><div class=right-buttons><a href=https://learnbyexample.github.io title=Blog aria-label=Blog> <i id=home-button class="fa fa-home"></i> </a><a href=https://twitter.com/learn_byexample title=Twitter aria-label=Twitter> <i id=twitter-button class="fa fa-twitter"></i> </a><a href=https://github.com/learnbyexample/cli-computing title="Git repository"aria-label="Git repository"> <i id=git-repository-button class="fa fa-github"></i> </a></div></div><div id=search-wrapper class=hidden><form id=searchbar-outer class=searchbar-outer><input type=search id=searchbar name=searchbar placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header></form><div id=searchresults-outer class="searchresults-outer hidden"><div id=searchresults-header class=searchresults-header></div><ul id=searchresults></ul></div></div><script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script><div id=content class=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=shell-scripting><a class=header href=#shell-scripting>Shell Scripting</a></h1><p>This chapter will cover basics of shell scripting with <code>bash</code>. You'll learn about declaring variables, control structures, working with arguments passed to a script, getting user input and so on.<blockquote><p><img src=./images/info.svg alt=info> The <a href=https://github.com/learnbyexample/cli-computing/tree/master/example_files>example_files</a> directory has all the shell scripts discussed in this chapter. However, it is recommended that you type the scripts manually using your favorite text editor and refer to the <code>example_files/shell_scripting</code> directory only when necessary.</blockquote><h2 id=need-for-scripting><a class=header href=#need-for-scripting>Need for scripting</a></h2><p>From <a href=https://en.wikipedia.org/wiki/Scripting_language>wikipedia: Scripting language</a>:<blockquote><p>A scripting language or script language is a programming language for a runtime system that automates the execution of tasks that would otherwise be performed individually by a human operator. Scripting languages are usually interpreted at runtime rather than compiled.</blockquote><blockquote><p>Typical scripting languages are intended to be very fast to learn and write in, either as short source code files or interactively in a read–eval–print loop (REPL, language shell). This generally implies relatively simple syntax and semantics; typically a "script" (code written in the scripting language) is executed from start to finish, as a "script", with no explicit entry point.</blockquote><p>From <a href=https://en.wikipedia.org/wiki/Shell_script>wikipedia: Shell script</a>:<blockquote><p>A shell script is a computer program designed to be run by the Unix shell, a command-line interpreter. The various dialects of shell scripts are considered to be scripting languages. Typical operations performed by shell scripts include file manipulation, program execution, and printing text. A script which sets up the environment, runs the program, and does any necessary cleanup or logging, is called a wrapper.</blockquote><p>See also <a href=https://stackoverflow.com/q/17253545/4082052>Difference between scripting and programming languages</a>.<h2 id=executable-script><a class=header href=#executable-script>Executable script</a></h2><p>There are several ways you can execute commands from a file. This section shows an example of creating an executable script. Consider this sample script saved in a file named <code>hello.sh</code>:<pre><code class=language-bash>#!/bin/bash

echo "Hello $USER"
echo "Today is $(date -u +%A)"
echo 'Have a nice day'
</code></pre><p>The first line in the above script has two parts:<ul><li><code>/bin/bash</code> is the path of <code>bash</code> interpreter <ul><li>you can use <code>type bash</code> to get the path on your system</ul><li><code>#!</code> is known as <a href=https://en.wikipedia.org/wiki/Shebang_(Unix)>shebang or hashbang</a> which directs the program loader to use the interpreter path provided <ul><li>see also <a href=https://stackoverflow.com/q/21612980>stackoverflow: comparison between #!/usr/bin/env and #!/bin/bash?</a><li>the <code>#</code> character starts a comment, <code>#!</code> is only special at the start of the script</ul></ul><p>Use <code>chmod</code> to add executable permission to the file and then run the script:<pre><code class=language-bash>$ chmod +x hello.sh

$ ./hello_world.sh 
Hello learnbyexample
Today is Wednesday
Have a nice day
</code></pre><p>If you want to use just the script name to execute it, the file has to be located in one of the <code>PATH</code> folders. Otherwise, you'll have to provide the script's path (absolute or relative) in order to execute it (as shown in the above illustration).<blockquote><p><img src=images/info.svg alt=info> <code>.sh</code> is typically used as the file extension for shell scripts. It is also common to <em>not</em> have an extension at all, especially for executable scripts.</blockquote><h2 id=passing-file-argument-to-bash><a class=header href=#passing-file-argument-to-bash>Passing file argument to bash</a></h2><p>You can also just pass a regular file as an argument to the <code>bash</code> command. In this case, the shebang isn't needed (though it wouldn't cause any issues either, since it will be treated as a comment).<pre><code class=language-bash>$ cat greeting.sh
echo 'hello'
echo 'have a nice day'

$ bash greeting.sh
hello
have a nice day
</code></pre><h2 id=sourcing-script><a class=header href=#sourcing-script>Sourcing script</a></h2><p>Yet another way to execute a script is to <em>source</em> it using the <code>source</code> (or <code>.</code>) builtin command. A major difference from the previous methods is that the script is executed in the current shell environment context instead of a sub-shell. A common use case is sourcing <code>~/.bashrc</code> and alias/functions (if they are saved in a separate file).<p>Here's an example:<pre><code class=language-bash>$ cat prev_cmd.sh
prev=$(fc -ln -2 | sed 's/^\s*//; q')
echo "$prev"

# 'echo' here is just a sample command for illustration purposes
$ echo 'hello'
hello
# sourcing the script correctly gives the previous command
$ source prev_cmd.sh
echo 'hello'

$ echo 'hello'
hello
# no output when the script is executed in a sub-shell
$ bash prev_cmd.sh
</code></pre><blockquote><p><img src=./images/info.svg alt=info> <code>fc</code> is a builtin command to manipulate the history of commands you've used from the terminal. See <a href=https://www.gnu.org/software/bash/manual/bash.html#Bash-History-Builtins>bash manual: History Builtins</a> for more details.</blockquote><h2 id=comments><a class=header href=#comments>Comments</a></h2><p>Single line comments can be inserted after the <code>#</code> character, either at the start of a line or after an instruction.<pre><code class=language-bash>$ cat comments.sh
# this is a comment on its own line
echo 'hello' # and this is a comment after a command

$ bash comments.sh
hello
</code></pre><blockquote><p><img src=images/info.svg alt=info> See this <a href=https://unix.stackexchange.com/q/37411/109046>unix.stackexchange thread</a> for emulating multiline comments.</blockquote><h2 id=variables><a class=header href=#variables>Variables</a></h2><p>Here's a basic example of assigning a variable and accessing its value:<pre><code class=language-bash>$ name='learnbyexample'

$ echo "$name"
learnbyexample
</code></pre><p>As seen above, you need to use the <code>$</code> prefix while accessing the value stored in a variable. You can use <code>${variable}</code> syntax to distinguish between the variable and other parts of the string. Using appropriate quotes is recommended, unless otherwise necessary.<p>You can append to a variable by using the <code>+=</code> operator. Here's an example:<pre><code class=language-bash>$ colors='blue'
$ echo "$colors"
blue

$ colors+=' green'
$ echo "$colors"
blue green
</code></pre><p>You can use the <code>declare</code> builtin to add attributes to variables. For example, the <code>-i</code> option for treating the variable as an integer, <code>-r</code> option for readonly, etc. These attributes can change the behavior of operators like <code>=</code> and <code>+=</code> for those variables. See <a href=https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameters>bash manual: Shell-Parameters</a> and <a href=https://www.gnu.org/software/bash/manual/bash.html#index-declare>bash manual: declare</a> for more details.<pre><code class=language-bash>$ declare -i num=5
$ echo "$num"
5
$ num+=42
$ echo "$num"
47

$ declare -r color='brown'
$ echo "$color"
brown
$ color+=' green'
bash: color: readonly variable
</code></pre><blockquote><p><img src=./images/info.svg alt=info> <img src=./images/warning.svg alt=warning> Assigning variables is one of the most common source for errors. Unlike most programming languages, spaces are <em>not</em> allowed around the <code>=</code> sign. That is because space is a shell metacharacter. Another common issue is using quotes (or not) around the value. Here are some examples:</blockquote><pre><code class=language-bash>$ num = 42
num: command not found

$ greeting=hello world
world: command not found
$ greeting='hello world'
$ echo "$greeting"
hello world

# using quotes is NOT desirable here
$ dir_path=~/reports
$ echo "$dir_path"
/home/learnbyexample/reports
$ dir_path='~/reports'
$ echo "$dir_path"
~/reports
</code></pre><h2 id=arrays><a class=header href=#arrays>Arrays</a></h2><p>From <a href=https://www.gnu.org/software/bash/manual/bash.html#Arrays>bash manual: Arrays</a>:<blockquote><p>Bash provides one-dimensional indexed and associative array variables. Any variable may be used as an indexed array; the <code>declare</code> builtin will explicitly declare an array. There is no maximum limit on the size of an array, nor any requirement that members be indexed or assigned contiguously. Indexed arrays are referenced using integers and are zero-based; associative arrays use arbitrary strings.</blockquote><p>Here's an example of assigning an array and various ways of accessing the elements:<pre><code class=language-bash>$ fruits=('apple' 'fig' 'mango')

# first element
$ echo "${fruits[0]}"
apple

# last element
$ echo "${fruits[-1]}"
mango

# all elements
# example with for loop will be discussed later on
$ echo "${fruits[@]}"
apple fig mango
$ printf '%s\n' "${fruits[@]}"
apple
fig
mango
</code></pre><h2 id=parameter-expansion><a class=header href=#parameter-expansion>Parameter Expansion</a></h2><p>Bash provides several useful ways to extract and modify contents of parameters and variables (including arrays). Some of these features will be discussed in this section.<p>Substring extraction using <code>${parameter:offset}</code> syntax to get all characters from the given index:<pre><code class=language-bash>$ city='Lucknow'

# all characters from index 4 onwards
# indexing starts from 0
$ echo "${city:4}"
now

# last two characters
# space before the negative sign is compulsory here,
# since ${parameter:-word} is a different feature
$ echo "${city: -2}"
ow
</code></pre><p>Substring extraction using <code>${parameter:offset:length}</code> syntax to get specific number of characters from the given index:<pre><code class=language-bash>$ city='Lucknow'

# 4 characters starting from index 0
$ echo "${city:0:4}"
Luck

# 2 characters starting from index -4 (4th character from the end)
$ echo "${city: -4:2}"
kn
</code></pre><p>When applied to arrays, substring extraction will give you those elements:<pre><code class=language-bash>$ fruits=('apple' 'fig' 'mango')

# all elements from index 1
$ echo "${fruits[@]:1}"
fig mango
</code></pre><p><code>${#parameter}</code> will give you the length of the string and <code>${#array[@]}</code> will give you the number of elements in the array:<pre><code class=language-bash>$ city='Lucknow'
$ echo "${#city}"
7

$ fruits=('apple' 'fig' 'mango')
$ echo "${#fruits[@]}"
3
</code></pre><p><code>${parameter#glob}</code> will remove the shortest match from the start of the string. You can also use extended globs if enabled via <code>shopt</code> builtin. <code>${parameter##glob}</code> will remove the longest match from the start of the string. Here are some examples:<pre><code class=language-bash>$ s='this is his life history'

# shortest match is deleted
$ echo "${s#*is}"
 is his life history
# longest match is deleted
$ echo "${s##*is}"
tory

# assuming extglob is enabled
$ echo "${s#+([^ ])}"
his is his life history
$ echo "${s##+([^ ])}"
 is his life history

# for arrays, the processing is applied to each element
$ fruits=('apple' 'fig' 'mango')
$ echo "${fruits[@]#*[aeiou]}"
pple g ngo
</code></pre><p><code>${parameter%glob}</code> will remove the shortest match from the end of the string. <code>${parameter%%glob}</code> will remove the longest match from the end of the string. Here are some examples:<pre><code class=language-bash>$ s='this is his life history'

$ echo "${s%is*}"
this is his life h
$ echo "${s%%is*}"
th

$ fruits=('apple' 'fig' 'mango')
$ echo "${fruits[@]%[aeiou]*}"
appl f mang
</code></pre><p><code>${parameter/glob/string}</code> will replace the first matching occurrence with the given replacement string and <code>${parameter//glob/string}</code> will replace all the matching occurrences. You can leave out the <code>/string</code> portion when you want to delete the matching occurrences. The <code>glob</code> will match the longest portion, similar to greedy behavior in regular expressions. Here are some examples:<pre><code class=language-bash>$ ip='this is a sample string'

# first occurrence of 'is' is replaced with '123'
$ echo "${ip/is/123}"
th123 is a sample string
# all occurrences of 'is' are replaced with '123'
$ echo "${ip//is/123}"
th123 123 a sample string

# replace all occurrences of 'am' or 'in' with '-'
$ echo "${ip//@(am|in)/-}"
this is a s-ple str-g

# matches from the first 'is' to the last 's' in the input
$ echo "${ip/is*s/ X }"
th X tring

# deletes first occurrence of 's'
$ echo "${ip/s}"
thi is a sample string
# deletes all occurrences of 's'
$ echo "${ip//s}"
thi i a ample tring
</code></pre><p><code>${parameter/#glob/string}</code> will match only at the start of the string and <code>${parameter/%glob/string}</code> will match only at the end of the string.<pre><code class=language-bash>$ ip='spare'

# remove only from the start of the string
$ echo "${ip/#sp}"
are
$ echo "${ip/#par}"
spare
# example with replacement string
$ echo "${ip/#sp/fl}"
flare

# remove only from the end of the string
$ echo "${ip/%re}"
spa
$ echo "${ip/%par}"
spare
</code></pre><p><code>${parameter^glob}</code> changes the first character to uppercase if matched by the glob. <code>${parameter^^glob}</code> changes all the matching characters to uppercase. You should provide a glob that only matches one character in length. If the glob is omitted, entire parameter will be matched. These rules also apply to the lowercase and swap case versions discussed later.<pre><code class=language-bash>$ fruit='apple'

# uppercase the first character
$ echo "${fruit^}"
Apple
# uppercase the entire parameter
$ echo "${fruit^^}"
APPLE

# first character doesn't match the 'g-z' range, so no change
$ echo "${fruit^[g-z]}"
apple
# uppercase all letters in the 'g-z' range
$ echo "${fruit^^[g-z]}"
aPPLe
# uppercase all letters in the 'a-e' or 'j-m' ranges
$ echo "${fruit^^[a-ej-m]}"
AppLE

# this won't work since 'sky-' is not a single character
$ color='sky-rose'
$ echo "${color^^*-}"
sky-rose
</code></pre><p>To change the characters to lowercase, use <code>,</code> and <code>,,</code> as shown below:<pre><code class=language-bash>$ fruit='APPLE'

$ echo "${fruit,}"
aPPLE
$ echo "${fruit,,}"
apple

$ echo "${fruit,,[G-Z]}"
ApplE
</code></pre><p>To swap case, use <code>~</code> and <code>~~</code> as shown below:<pre><code class=language-bash>$ fruit='aPPle'

# swap case only for the first character
$ echo "${fruit~}"
APPle
# swap case for all the characters
$ echo "${fruit~~}"
AppLE

# swap case for characters matching the given character set
$ echo "${fruit~~[g-zG-Z]}"
appLe
</code></pre><blockquote><p><img src=images/info.svg alt=info> See <a href=https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameter-Expansion>bash manual: Shell Parameter Expansion</a> for more details and other types of expansions.</blockquote><h2 id=command-line-arguments><a class=header href=#command-line-arguments>Command Line Arguments</a></h2><p>Command line arguments passed to a script (or a function) are saved in positional parameters starting with <code>1</code>, <code>2</code>, <code>3</code> etc. <code>0</code> contains the name of the shell or shell script. <code>@</code> contains all the positional parameters starting from <code>1</code>. Use <code>#</code> to get the number of positional parameters. Similar to variables, you need to use a <code>$</code> prefix to get the value stored in these parameters. If the parameter number requires more than a single digit, you have to necessarily enclose them in <code>{}</code> (for example, <code>${12}</code> to get the value of the twelfth parameter).<p>Here's an example script that accepts two arguments:<pre><code class=language-bash>$ cat command_line_arguments.sh
echo "No. of lines in '$1' is $(wc -l < "$1")"
echo "No. of lines in '$2' is $(wc -l < "$2")"

$ seq 12 > 'test file.txt'

$ bash command_line_arguments.sh hello.sh test\ file.txt 
No. of lines in 'hello.sh' is 5
No. of lines in 'test file.txt' is 12
</code></pre><p><strong>Further Reading</strong><ul><li><a href=https://unix.stackexchange.com/q/131766/109046>unix.stackexchange: Why does my shell script choke on whitespace or other special characters?</a><li><a href=https://www.gnu.org/software/bash/manual/bash.html#Special-Parameters>bash manual: Special Parameters</a></ul><h2 id=conditional-expressions><a class=header href=#conditional-expressions>Conditional Expressions</a></h2><p>You can test a condition within <code>[[</code> and <code>]]</code> to get a success (<code>0</code>) or failure (<code>1</code> or higher) exit status and take action accordingly. Bash provides several options and operators that you can use. Space is required after <code>[[</code> and before <code>]]</code> for this compound command to function.<blockquote><p><img src=./images/info.svg alt=info> Operators <code>;</code>, <code>&&</code> and <code>||</code> will be used in this section to keep the examples terser. <code>if-else</code> and other control structures will be discussed later.</blockquote><h3 id=options><a class=header href=#options>Options</a></h3><p>The <code>-e</code> option checks if the given path argument exists or not. Add a <code>!</code> prefix to negate the condition.<pre><code class=language-bash># change to the 'example_files/shell_scripting' directory for this section

$ [[ -e hello.sh ]] && echo 'file exists' || echo 'not found'
file exists

$ [[ -e xyz.txt ]] && echo 'file exists' || echo 'not found'
not found

# exit status
$ [[ -e hello.sh ]] ; echo $?
0
$ [[ -e xyz.txt ]] ; echo $?
1
$ [[ ! -e xyz.txt ]] ; echo $?
0
</code></pre><p>You can use <code>-d</code> and <code>-f</code> to check if the path is a valid directory and file respectively. The <code>-s</code> option checks if the file exists and its size is greater than zero. The <code>-x</code> option checks if the file exists and is executable. See <a href=https://www.gnu.org/software/bash/manual/bash.html#Bash-Conditional-Expressions>bash manual: Conditional Expressions</a> for a complete list of such options.<h3 id=string-comparisons><a class=header href=#string-comparisons>String comparisons</a></h3><ul><li><code>s1 = s2</code> or <code>s1 == s2</code> checks if two strings are equal <ul><li>unquoted portions of <code>s2</code> will be treated as a wildcard while testing against <code>s1</code><li><code>extglob</code> would be considered as enabled for comparison purposes</ul><li><code>s1 != s2</code> checks if strings are <em>not</em> equal <ul><li>unquoted portions of <code>s2</code> will be treated as a wildcard while testing against <code>s1</code><li><code>extglob</code> would be considered as enabled for comparison purposes</ul><li><code>s1 < s2</code> checks if <code>s1</code> sorts before <code>s2</code> lexicographically<li><code>s1 > s2</code> checks if <code>s1</code> sorts after <code>s2</code> lexicographically<li><code>s1 =~ s2</code> checks if <code>s1</code> matches the POSIX extended regular expression provided by <code>s2</code> <ul><li>exit status will be <code>2</code> if <code>s2</code> is not a valid regexp</ul></ul><p>Here are some examples for equal and not-equal comparisons:<pre><code class=language-bash>$ fruit='apple'
$ [[ $fruit == 'apple' ]] && echo 'true' || echo 'false'
true
$ [[ $fruit == 'banana' ]] && echo 'true' || echo 'false'
false

# glob should be constructed to match the entire string
$ [[ hello == h* ]] && echo 'true' || echo 'false'
true
# don't quote the glob!
$ [[ hello == 'h*' ]] && echo 'true' || echo 'false'
false

# another example to emphasize that the glob should match the entire string
$ [[ hello == e*o ]] && echo 'true' || echo 'false'
false
$ [[ hello == *e*o ]] && echo 'true' || echo 'false'
true

$ [[ hello != *a* ]] && echo 'true' || echo 'false'
true
$ [[ hello != *e* ]] && echo 'true' || echo 'false'
false
</code></pre><p>Here are some examples for greater-than and less-than comparisons:<pre><code class=language-bash>$ [[ apple < banana ]] && echo 'true' || echo 'false'
true
$ [[ par < part ]] && echo 'true' || echo 'false'
true

$ [[ mango > banana ]] && echo 'true' || echo 'false'
true
$ [[ sun > moon && fig < papaya ]] && echo 'true' || echo 'false'
true

# don't use this to compare numbers!
$ [[ 20 > 3 ]] && echo 'true' || echo 'false'
false
# -gt and other such operators will be discussed later
$ [[ 20 -gt 3 ]] && echo 'true' || echo 'false'
true
</code></pre><p>Here are some examples for regexp comparison. You can use the special array <code>BASH_REMATCH</code> to retrieve specific portions of the string that was matched.<pre><code class=language-bash>$ fruit='apple'
$ [[ $fruit =~ ^a ]] && echo 'true' || echo 'false'
true
$ [[ $fruit =~ ^b ]] && echo 'true' || echo 'false'
false

# entire matched portion
$ [[ $fruit =~ a.. ]] && echo "${BASH_REMATCH[0]}"
app
# portion matched by the first capture group
$ [[ $fruit =~ a(..) ]] && echo "${BASH_REMATCH[1]}"
pp
</code></pre><h3 id=numeric-comparisons><a class=header href=#numeric-comparisons>Numeric comparisons</a></h3><ul><li><code>n1 -eq n2</code> checks if two numbers are equal<li><code>n1 -ne n2</code> checks if two numbers are <em>not</em> equal<li><code>n1 -gt n2</code> checks if <code>n1</code> is greater than <code>n2</code><li><code>n1 -ge n2</code> checks if <code>n1</code> is greater than or equal to <code>n2</code><li><code>n1 -lt n2</code> checks if <code>n1</code> is less than <code>n2</code><li><code>n1 -le n2</code> checks if <code>n1</code> is less than or equal to <code>n2</code></ul><p>Only positive or negative integer comparisons are supported by these operators.<pre><code class=language-bash>$ [[ 20 -gt 3 ]] && echo 'true' || echo 'false'
true

$ n1='42'
$ n2='25'
$ [[ $n1 -gt 30 && $n2 -lt 12 ]] && echo 'true' || echo 'false'
false
</code></pre><p>Numeric arithmetic operations and comparisons can be performed within <code>((</code> and <code>))</code> compound command. Here are some sample comparisons:<pre><code class=language-bash>$ (( 20 > 3 )) && echo 'true' || echo 'false'

$ n1='42'
$ n2='25'
$ (( n1 > 30 && n2 < 12 )) && echo 'true' || echo 'false'
false
</code></pre><blockquote><p><img src=images/info.svg alt=info> Note that the <code>$</code> prefix was <em>not</em> used for variables in the above example. See <a href=https://www.gnu.org/software/bash/manual/bash.html#Shell-Arithmetic>bash manual: Shell Arithmetic</a> for more details.</blockquote><h2 id=accepting-user-input-interactively><a class=header href=#accepting-user-input-interactively>Accepting user input interactively</a></h2><p>You can use the <code>read</code> builtin command to accept input from the user interactively. If multiple variables are given as arguments to the <code>read</code> command, values will be assigned based on whitespace separation. Any pending values will be assigned to the last variable. Here are some examples:<pre><code class=language-bash># press 'Enter' after the 'read' command
# and also after you've finished entering the input
$ read color
light green
$ echo $color
light green

# example with multiple variables
$ read fruit qty
apple 10
$ echo "${fruit}: ${qty}"
apple: 10
</code></pre><p>The <code>-p</code> option helps you to add a user prompt. Here is an example of getting two arguments from the user:<pre><code class=language-bash>$ cat user_input.sh
read -p 'Enter two integers separated by spaces: ' num1 num2
sum=$(( num1 + num2 ))
echo "$num1 + $num2 = $sum"

$ bash user_input.sh
Enter two integers separated by spaces: -2 42
-2 + 42 = 40
</code></pre><blockquote><p><img src=images/info.svg alt=info> You can use the <code>-a</code> option to assign an array, the <code>-d</code> option to specify a custom delimiter instead of newline and so on. See <code>help read</code> or <a href=https://www.gnu.org/software/bash/manual/bash.html#Bash-Builtins>bash manual: Builtins</a> for more details.</blockquote><h2 id=if-then-else><a class=header href=#if-then-else>if then else</a></h2><p>The keywords needed to construct an <code>if</code> control structure are <code>if</code>, <code>then</code>, <code>fi</code> and optionally <code>else</code> and <code>elif</code>. You can use compound commands like <code>[[</code> and <code>((</code> to provide the test condition. You can also directly use a command's exit status. Here's an example script:<pre><code class=language-bash>$ cat if_then_else.sh
if (( $# != 1 )) ; then
    echo 'Error! One file argument expected.' 1>&2
    exit 1
else
    if [[ ! -f $1 ]] ; then
        printf 'Error! %q is not a valid file\n' "$1" 1>&2
        exit 1
    else
        echo "No. of lines in '$1' is $(wc -l < "$1")"
    fi
fi
</code></pre><p><code>1>&2</code> is used in the above script to redirect error messages to the <code>stderr</code> stream. Sample script invocations are shown below:<pre><code class=language-bash>$ bash if_then_else.sh
Error! One file argument expected.
$ echo $?
1

$ bash if_then_else.sh xyz.txt
Error! 'xyz.txt' is not a valid file
$ echo $?
1

$ bash if_then_else.sh hello.sh
No. of lines in 'hello.sh' is 5
$ echo $?
0
</code></pre><p>Sometimes you just need to know if the intended command operation was successful or not and then take an action depending on the outcome. In such cases, you can provide the command directly after the <code>if</code> keyword. Note that <code>stdout</code> and <code>stderr</code> of the command will still be active unless redirected or suppressed using appropriate options.<p>For example, the <code>grep</code> command supports <code>-q</code> option to suppress <code>stdout</code>. Here's a script using that feature:<pre><code class=language-bash>$ cat search.sh 
read -p 'Enter a search pattern: ' search

if grep -q "$search" hello.sh ; then
    echo "match found"
else
    echo "match not found"
fi
</code></pre><p>Sample invocations for the above script:<pre><code class=language-bash>$ bash search.sh
Enter a search pattern: echo
match found

$ bash search.sh
Enter a search pattern: xyz
match not found
</code></pre><h2 id=for-loop><a class=header href=#for-loop>for loop</a></h2><p>To construct a <code>for</code> loop, you'll need the <code>for</code>, <code>do</code> and <code>done</code> keywords. Here are some examples:<pre><code class=language-bash># iterate over numbers generated using brace expansion
$ for num in {2..4}; do echo "$num"; done
2
3
4

# iterate over files matched using wildcards
# echo is used here for dry run testing
$ for file in [gh]*.sh; do echo mv "$file" "$file.bkp"; done
mv greeting.sh greeting.sh.bkp
mv hello.sh hello.sh.bkp
</code></pre><p>As seen in the above examples, the space separated arguments provided after the <code>in</code> keyword are automatically assigned to the variable provided after the <code>for</code> keyword during each iteration.<p>Here's a modified example of the last example that accepts user provided command line arguments:<pre><code class=language-bash>$ cat for_loop.sh
for file in "$@"; do 
    echo mv "$file" "$file.bkp"
done

$ bash for_loop.sh [gh]*.sh
mv greeting.sh greeting.sh.bkp
mv hello.sh hello.sh.bkp

$ bash for_loop.sh report.log ip.txt fruits.txt
mv report.log report.log.bkp
mv ip.txt ip.txt.bkp
mv fruits.txt fruits.txt.bkp
</code></pre><p>Here's an example of iterating over an array:<pre><code class=language-bash>$ files=('report.log' 'pass_list.txt')
$ for f in "${files[@]}"; do echo "$f"; done
report.log
pass_list.txt
</code></pre><blockquote><p><img src=images/info.svg alt=info> You can use <code>continue</code> and <code>break</code> to alter the loop flow depending on specific conditions. See <a href=https://www.gnu.org/software/bash/manual/bash.html#Bourne-Shell-Builtins>bash manual: Bourne Shell Builtins</a> for more details.</blockquote><blockquote><p><img src=./images/info.svg alt=info> <code>for file;</code> is same as <code>for file in "$@";</code> since <code>in "$@"</code> is the default. I'd recommend using the explicit version.</blockquote><h2 id=while-loop><a class=header href=#while-loop>while loop</a></h2><p>Here's a simple <code>while</code> loop construct. You'll see a more practical example later in this chapter.<pre><code class=language-bash>$ cat while_loop.sh
i="$1"
while (( i > 0 )) ; do
    echo "$i"
    (( i-- ))
done

$ bash while_loop.sh 3
3
2
1
</code></pre><h2 id=reading-a-file><a class=header href=#reading-a-file>Reading a file</a></h2><p>The <code>while</code> loop combined with the <code>read</code> builtin helps you to process the content of a file. Here's an example of reading input contents line by line:<pre><code class=language-bash>$ cat read_file_lines.sh
while IFS= read -r line; do
    # do something with each line
    wc -l "$line"
done < "$1"

$ printf 'hello.sh\ngreeting.sh\n' > files.txt
$ bash read_file_lines.sh files.txt
5 hello.sh
2 greeting.sh
</code></pre><p>The intention in the above script is to treat each input line literally. So, the <code>IFS</code> special variable is set to empty string to prevent stripping of leading and trailing whitespaces. The <code>-r</code> option to the <code>read</code> builtin allows <code>\</code> in input to be treated literally. Note that the input filename is accepted as the first command line argument and redirected as <code>stdin</code> to the <code>while</code> loop. You also need to make sure that the last line of input ends with a newline character, otherwise the last line won't be processed.<p>You can change <code>IFS</code> to split the input line into different fields and specify appropriate number of variables to the <code>read</code> builtin. Here's an example:<pre><code class=language-bash>$ cat read_file_fields.sh
while IFS=' : ' read -r field1 field2; do
    echo "$field2,$field1"
done < "$1"

$ bash read_file_fields.sh <(printf 'apple : 3\nfig : 100\n')
3,apple
100,fig
</code></pre><p>You can pass a number to the <code>-n</code> option for the <code>read</code> builtin to process the input that many characters at a time. Here's an example:<pre><code class=language-bash>$ while read -r -n2 ip; do echo "$ip"; done <<< '\word'
\w
or
d
</code></pre><blockquote><p><img src=./images/info.svg alt=info> The <code>xargs</code> command can also be used for some of the cases discussed above. See <a href=https://unix.stackexchange.com/q/149726/109046>unix.stackexchange: parse each line of a text file as an argument to a command</a> for an example.</blockquote><h2 id=functions><a class=header href=#functions>Functions</a></h2><p>From <a href=https://www.gnu.org/software/bash/manual/bash.html#Shell-Functions>bash manual: Shell Functions</a>:<blockquote><p>Shell functions are a way to group commands for later execution using a single name for the group. They are executed just like a "regular" command. When the name of a shell function is used as a simple command name, the list of commands associated with that function name is executed. Shell functions are executed in the current shell context; no new process is created to interpret them.</blockquote><p>You can use either of the syntax shown below to declare functions:<pre><code class=language-bash>fname () compound-command [ redirections ]

function fname [()] compound-command [ redirections ]
</code></pre><p>Arguments to functions are passed in the same manner as those discussed earlier for shell scripts. Here's an example:<pre><code class=language-bash>$ cat functions.sh
add_border ()
{
    size='10'
    color='grey'
    if (( $# == 1 )) ; then
        ip="$1"
    elif (( $# == 2 )) ; then
        if [[ $1 =~ ^[0-9]+$ ]] ; then
            size="$1"
        else
            color="$1"
        fi
        ip="$2"
    else
        size="$1"
        color="$2"
        ip="$3"
    fi

    op="${ip%.*}_border.${ip##*.}"
    echo convert -border "$size" -bordercolor "$color" "$ip" "$op"
}

add_border flower.png
add_border 5 insect.png
add_border red lake.png
add_border 20 blue sky.png
</code></pre><p>In the above example, <code>echo</code> is used to display the command that will be executed. Remove <code>echo</code> if you want this script to actually create new images with the given parameters. The function accepts one to three arguments and uses default values when some of the arguments are not passed. Here's the output:<pre><code class=language-bash>$ bash functions.sh
convert -border 10 -bordercolor grey flower.png flower_border.png
convert -border 5 -bordercolor grey insect.png insect_border.png
convert -border 10 -bordercolor red lake.png lake_border.png
convert -border 20 -bordercolor blue sky.png sky_border.png
</code></pre><blockquote><p><img src=images/info.svg alt=info> Use <code>mogrify</code> instead of <code>convert</code> if you want to modify the input image inplace instead of creating a new image. These image manipulation commands are part of <a href=https://imagemagick.org/>ImageMagick</a>. As an exercise, modify the above function to generate error if the arguments passed do not match the expected usage. You can also accept output image name (or perhaps a different suffix) as an additional argument.</blockquote><p>The shell script and user defined functions (which in turn might call itself or another function) can both have positional arguments. In such cases, the shell takes cares of restoring positional arguments to the earlier state once a function completes its tasks.<p>Functions have exit status as well, which is based on the last executed command by default. You can use the <code>return</code> builtin to provide your own custom exit status.<h2 id=debugging><a class=header href=#debugging>Debugging</a></h2><p>You can use the following <code>bash</code> options for debugging purposes:<ul><li><code>-x</code> print commands and their arguments as they are executed<li><code>-v</code> verbose option, print shell input lines as they are read</ul><p>Here's an example with <code>bash -x</code> option:<pre><code class=language-bash>$ bash -x search.sh
+ read -p 'Enter a search pattern: ' search
Enter a search pattern: xyz
+ grep -q xyz hello.sh
+ echo 'match not found'
match not found
</code></pre><p>In the above illustration, the lines starting with <code>+</code> show the command being executed with expanded values if applicable (the <code>search</code> variable to <code>grep -q</code> for example). Multiple <code>+</code> will be used if there are multiple expansions. Here's how <code>bash -xv</code> would behave for the same script:<pre><code class=language-bash>$ bash -xv search.sh
read -p 'Enter a search pattern: ' search
+ read -p 'Enter a search pattern: ' search
Enter a search pattern: xyz

if grep -q "$search" hello.sh ; then
    echo "match found"
else
    echo "match not found"
fi
+ grep -q xyz hello.sh
+ echo 'match not found'
match not found
</code></pre><blockquote><p><img src=images/info.svg alt=info> You can also use <code>set -x</code> or <code>set -v</code> or <code>set -xv</code> from within the script to debug from a particular point onwards. You can turn off such debugging by using <code>+</code> instead of <code>-</code> as the option prefix (for example, <code>set +x</code>).</blockquote><h2 id=shellcheck><a class=header href=#shellcheck>shellcheck</a></h2><p><a href=https://www.shellcheck.net/>shellcheck</a> is a static analysis tool that gives warnings and suggestions for scripts. You can use it online or install the tool for offline use. Given the various <code>bash</code> gotchas, this tool is highly recommended for both beginners and advanced users.<p>Consider this script:<pre><code class=language-bash>$ cat bad_script.sh
#!/bin/bash

greeting = 'hello world'
echo "$greeting"
</code></pre><p>Here's how <code>shellcheck</code> reports the issue:<pre><code class=language-bash>$ shellcheck bad_script.sh

In bad_script.sh line 3:
greeting = 'hello world'
         ^-- SC1068: Don't put spaces around the = in assignments
                     (or quote to make it literal).

For more information:
  https://www.shellcheck.net/wiki/SC1068 -- Don't put spaces around the = in ...
</code></pre><blockquote><p><img src=images/info.svg alt=info> Use the <code>-s</code> option (<code>shellcheck -s bash</code> for example) to specify the shell being used, if the script doesn't have a shebang.</blockquote><blockquote><p><img src=images/info.svg alt=info> <img src=./images/warning.svg alt=warning> Note that <code>shellcheck</code> will not catch all types of issues. And suggestions should not be blindly accepted without understanding if that makes sense in the given context.</blockquote><h2 id=resource-lists><a class=header href=#resource-lists>Resource lists</a></h2><p>Here are some more learning resources:<p><strong>Shell Scripting</strong><ul><li><a href=https://mywiki.wooledge.org/BashGuide>Bash Guide</a> — aspires to teach good practice techniques for using Bash, and writing simple scripts<li><a href=https://ryanstutorials.net/bash-scripting-tutorial/>Bash Scripting Tutorial</a> — solid foundation in how to write Bash scripts, to get the computer to do complex, repetitive tasks for you<li><a href=https://github.com/denysdovhan/bash-handbook>bash-handbook</a> — for those who want to learn Bash without diving in too deeply<li><a href=https://freebsdfrau.gitbook.io/serious-shell-programming/>Serious Shell Programming</a> — focuses on POSIX-compliant Bourne Shell for portability</ul><p><strong>Handy tools, tips and reference</strong><ul><li><a href=https://www.shellcheck.net/>shellcheck</a> — linting tool to avoid common mistakes and improve your script<li><a href=https://devmanual.gentoo.org/tools-reference/bash/index.html>Bash reference cheatsheet</a> — nicely formatted and explained well<li><a href=https://devhints.io/bash>Bash scripting cheatsheet</a> — quick reference to getting started with Bash scripting<li>Comprehensive lists on <code>mywiki.wooledge.org</code> website: <ul><li><a href=https://mywiki.wooledge.org/BashFAQ>Bash FAQ</a><li><a href=https://mywiki.wooledge.org/BashGuide/Practices>Bash Practices</a><li><a href=https://mywiki.wooledge.org/BashPitfalls>Bash Pitfalls</a></ul><li><a href=https://google.github.io/styleguide/shellguide.html>Google shell style guide</a><li>Reliability and robustness <ul><li><a href=https://github.com/anordal/shellharden/blob/master/how_to_do_things_safely_in_bash.md>safe ways to do things in bash</a><li><a href=https://robertmuth.blogspot.in/2012/08/better-bash-scripting-in-15-minutes.html>better scripting</a><li><a href=https://www.davidpashley.com/articles/writing-robust-shell-scripts/>robust scripting</a></ul></ul><p><strong>Specific topics</strong><ul><li>Reading file(s) <ul><li><a href=https://mywiki.wooledge.org/BashFAQ/001>Reading file</a><li><a href=https://unix.stackexchange.com/q/82541/109046>Loop through the lines of two files in parallel</a></ul><li><a href=https://mywiki.wooledge.org/BashGuide/Arrays>arrays</a><li><a href=https://unix.stackexchange.com/q/288886/109046>nameref</a> <ul><li>also see this <a href=https://mywiki.wooledge.org/BashFAQ/006>FAQ</a></ul><li>getopts <ul><li><a href=https://wiki.bash-hackers.org/howto/getopts_tutorial>getopts tutorial</a><li><a href=https://mywiki.wooledge.org/BashFAQ/035>handling command-line arguments</a><li><a href=https://stackoverflow.com/q/16483119/4082052>stackoverflow: getopts example</a></ul></ul><h2 id=exercises><a class=header href=#exercises>Exercises</a></h2><blockquote><p><img src=./images/info.svg alt=info> Use a temporary working directory before attempting the exercises. You can delete such practice directories afterwards.</blockquote><p><strong>1)</strong> What's wrong with the script shown below? Also, will the error go away if you use <code>bash try.sh</code> instead?<pre><code class=language-bash>$ printf '    \n!#/bin/bash\n\necho hello\n' > try.sh
$ chmod +x try.sh
$ ./try.sh
./try.sh: line 2: !#/bin/bash: No such file or directory
hello

# expected output
$ ./try.sh
hello
</code></pre><p><strong>2)</strong> Will the command shown below work? If so, what would be the output?<pre><code class=language-bash>$ echo echo hello | bash
</code></pre><p><strong>3)</strong> When would you <code>source</code> a script instead of using <code>bash</code> or creating an executable using shebang?<p><strong>4)</strong> How would you display the contents of a variable with <code>shake</code> appended?<pre><code class=language-bash>$ fruit='banana'

$ echo # ???
bananashake
</code></pre><p><strong>5)</strong> What changes would you make to the code shown below to get the expected output?<pre><code class=language-bash># default behavior
$ n=100
$ n+=100
$ echo "$n"
100100

# expected output
$ echo "$n"
200
</code></pre><p><strong>6)</strong> Is the following code valid? If so, what would be the output of the <code>echo</code> command?<pre><code class=language-bash>$ declare -a colors
$ colors[3]='green'
$ colors[1]='blue'

# ???
$ echo "${colors[@]}"
</code></pre><p><strong>7)</strong> How would you get the last three characters of a variable's contents?<pre><code class=language-bash>$ fruit='banana'

# ???
ana
</code></pre><p><strong>8)</strong> Will the second <code>echo</code> command give an error? If not, what will be the output?<pre><code class=language-bash>$ fruits=('apple' 'fig' 'mango')
$ echo "${#fruits[@]}"
3

$ echo "${#fruits}"
# ???
</code></pre><p><strong>9)</strong> For the given the array, use parameter expansion to remove characters until first/last space.<pre><code class=language-bash>$ colors=('green' 'dark brown' 'deep sky blue white')

# remove till first space
$ printf '%s\n' # ???
green
brown
sky blue white

# remove till last space
$ printf '%s\n' # ???
green
brown
white
</code></pre><p><strong>10)</strong> Use parameter expansion to get the expected outputs shown below.<pre><code class=language-bash>$ ip='apple:banana:cherry:dragon'

$ echo # ???
apple:banana:cherry

$ echo # ???
apple
</code></pre><p><strong>11)</strong> Is it possible to achieve the expected outputs shown below using parameter expansion? If so, how?<pre><code class=language-bash>$ ip='apple:banana:cherry:dragon'

$ echo # ???
apple 42 dragon

$ echo # ???
fig:banana:cherry:dragon

$ echo # ???
apple:banana:cherry:end
</code></pre><p><strong>12)</strong> For the given input, change case as per the expected outputs shown below.<pre><code class=language-bash>$ ip='This is a Sample STRING'

$ echo # ???
THIS IS A SAMPLE STRING

$ echo # ???
this is a sample string

$ echo # ???
tHIS IS A sAMPLE string
</code></pre><p><strong>13)</strong> Why does the conditional expression shown below fail?<pre><code class=language-bash>$ touch ip.txt
$ [[-f ip.txt]] && echo 'file exists'
[[-f: command not found
</code></pre><p><strong>14)</strong> What is the difference between <code>==</code> and <code>=~</code> string comparison operators?<p><strong>15)</strong> Why does the conditional expression used below show <code>failed</code> both times? Modify the expression such that the first one correctly says <code>matched</code> instead of <code>failed</code>.<pre><code class=language-bash>$ f1='1234.txt'
$ f2='report_2.txt'

$ [[ $f1 == '+([0-9]).txt' ]] && echo 'matched' || echo 'failed'
failed
$ [[ $f2 == '+([0-9]).txt' ]] && echo 'matched' || echo 'failed'
failed
</code></pre><p><strong>16)</strong> Extract the digits that follow a <code>:</code> character for the given variable contents.<pre><code class=language-bash>$ item='chocolate:50'
# ???
50

$ item='50 apples, fig:100, books-12'
# ???
100
</code></pre><p><strong>17)</strong> Modify the conditional expression shown below such that it correctly reports <code>true</code> instead of <code>false</code>.<pre><code class=language-bash>$ num=12345
$ [[ $num > 3 ]] && echo 'true' || echo 'false'
false
</code></pre><p><strong>18)</strong> Write a shell script named <code>array.sh</code> that accepts array input from the user followed by another input as index. Display the corresponding value at that index. Couple of examples are shown below.<pre><code class=language-bash>$ bash array.sh
enter array elements: apple banana cherry
enter array index: 1
element at index '1' is: banana

$ bash array.sh
enter array elements: dragon unicorn centaur
enter array index: -1
element at index '-1' is: centaur
</code></pre><p><strong>19)</strong> Write a shell script named <code>case.sh</code> that accepts exactly two command line arguments. The first argument can be <code>lower</code>, <code>upper</code> or <code>swap</code> and this should be used to transform the contents of the second argument. Examples script invocations are shown below, including what should happen if the command line arguments do not meet the script expectations.<pre><code class=language-bash>$ ./case.sh upper 'how are you?'
HOW ARE YOU?

$ ./case.sh lower PineAPPLE
pineapple

$ ./case.sh swap 'HeLlo WoRlD'
hElLO wOrLd

$ ./case.sh lower
Error! Two arguments expected.
$ echo $?
1

$ ./case.sh upper apple fig
Error! Two arguments expected.

$ ./case.sh lowercase DRAGON
Error! 'lowercase' command not recognized.
$ echo $?
1

$ ./case.sh apple lower 2> /dev/null
$ echo $?
1
</code></pre><p><strong>20)</strong> Write a shell script named <code>loop.sh</code> that displays the number of lines for each of the files passed as command line arguments.<pre><code class=language-bash>$ printf 'apple\nbanana\ncherry\n' > items_1.txt
$ printf 'dragon\nowl\nunicorn\ntroll\ncentaur\n' > items_2.txt

$ bash loop.sh items_1.txt
number of lines in 'items_1.txt' is: 3

$ bash loop.sh items_1.txt items_2.txt
number of lines in 'items_1.txt' is: 3
number of lines in 'items_2.txt' is: 5
</code></pre></main><nav class=nav-wrapper aria-label="Page navigation"><a rel=prev href=assorted-text-processing-tools.html class="mobile-nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=shell-customization.html class="mobile-nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav class=nav-wide-wrapper aria-label="Page navigation"><a rel=prev href=assorted-text-processing-tools.html class="nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=shell-customization.html class="nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a></nav></div><script>
            window.playground_copyable = true;
        </script><script src=elasticlunr.min.js charset=utf-8></script><script src=mark.min.js charset=utf-8></script><script src=searcher.js charset=utf-8></script><script src=clipboard.min.js charset=utf-8></script><script src=highlight.js charset=utf-8></script><script src=book.js charset=utf-8></script><script src=sidebar.js></script>