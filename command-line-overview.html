<!doctypehtml><html class="sidebar-visible no-js light"lang=en><head><meta charset=UTF-8><title>Command Line Overview - Computing from the Command Line</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta content="Linux Command Line and Shell Scripting for beginner to intermediate level users"name=description><meta content=width=device-width,initial-scale=1 name=viewport><meta content=#ffffff name=theme-color><meta content="Computing from the Command Line"property=og:title><meta content=website property=og:type><meta content="Linux Command Line and Shell Scripting for beginner to intermediate level users"property=og:description><meta content=https://learnbyexample.github.io/cli-computing/ property=og:url><meta content=https://learnbyexample.github.io/cli-computing/images/cli_computing_ls.png property=og:image><meta content=1280 property=og:image:width><meta content=720 property=og:image:height><meta content=summary_large_image property=twitter:card><meta content=@learn_byexample property=twitter:site><link href=favicon.svg rel=icon><link rel="shortcut icon"href=favicon.png><link href=css/variables.css rel=stylesheet><link href=css/general.css rel=stylesheet><link href=css/chrome.css rel=stylesheet><link href=FontAwesome/css/font-awesome.css rel=stylesheet><link href=fonts/fonts.css rel=stylesheet><link href=highlight.css rel=stylesheet><link href=tomorrow-night.css rel=stylesheet><link href=ayu-highlight.css rel=stylesheet><link href=style.css rel=stylesheet><body><script>var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";</script><script>try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }</script><script>var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');</script><script>var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);</script><nav aria-label="Table of contents"class=sidebar id=sidebar><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=cover.html>Cover</a><li class="chapter-item expanded affix"><a href=buy.html>Buy PDF/EPUB versions</a><li class="chapter-item expanded affix"><a href=preface.html>Preface</a><li class="chapter-item expanded"><a href=introduction-setup.html><strong aria-hidden=true>1.</strong> Introduction and Setup</a><li class="chapter-item expanded"><a class=active href=command-line-overview.html><strong aria-hidden=true>2.</strong> Command Line Overview</a><li class="chapter-item expanded"><a href=managing-files-directories.html><strong aria-hidden=true>3.</strong> Managing Files and Directories</a><li class="chapter-item expanded"><a href=shell-features.html><strong aria-hidden=true>4.</strong> Shell Features</a><li class="chapter-item expanded"><a href=viewing-part-or-whole-file-contents.html><strong aria-hidden=true>5.</strong> Viewing Part or Whole File Contents</a><li class="chapter-item expanded"><a href=searching-files-and-filenames.html><strong aria-hidden=true>6.</strong> Searching Files and Filenames</a><li class="chapter-item expanded"><a href=file-properties.html><strong aria-hidden=true>7.</strong> File Properties</a><li class="chapter-item expanded"><a href=managing-processes.html><strong aria-hidden=true>8.</strong> Managing Processes</a><li class="chapter-item expanded"><a href=multipurpose-text-processing-tools.html><strong aria-hidden=true>9.</strong> Multipurpose Text Processing Tools</a><li class="chapter-item expanded"><a href=sorting-stuff.html><strong aria-hidden=true>10.</strong> Sorting Stuff</a><li class="chapter-item expanded"><a href=comparing-files.html><strong aria-hidden=true>11.</strong> Comparing Files</a><li class="chapter-item expanded"><a href=assorted-text-processing-tools.html><strong aria-hidden=true>12.</strong> Assorted Text Processing Tools</a><li class="chapter-item expanded"><a href=shell-scripting.html><strong aria-hidden=true>13.</strong> Shell Scripting</a><li class="chapter-item expanded"><a href=shell-customization.html><strong aria-hidden=true>14.</strong> Shell Customization</a><li class="chapter-item expanded affix"><a href=exercise-solutions.html>Exercise Solutions</a></li><br><hr><li class="chapter-item expanded"><i class="fa fa-github"id=git-repository-button></i><a href=https://github.com/learnbyexample/cli-computing>   Source code</a><li class="chapter-item expanded"><i class="fa fa-home"id=home-button></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i class="fa fa-book"id=book-button></i><a href=https://learnbyexample.github.io/books/>   My Books</a><li class="chapter-item expanded"><i class="fa fa-envelope"id=mail-button></i><a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>   learnbyexample weekly</a><li class="chapter-item expanded"><i class="fa fa-twitter"id=twitter-button></i><a href=https://twitter.com/learn_byexample>   Twitter</a></ol></div><div class=sidebar-resize-handle id=sidebar-resize-handle></div></nav><div class=page-wrapper id=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div class="menu-bar sticky bordered"id=menu-bar><div class=left-buttons><button aria-label="Toggle Table of Contents"title="Toggle Table of Contents"aria-controls=sidebar class=icon-button id=sidebar-toggle type=button><i class="fa fa-bars"></i></button><button aria-label="Change theme"title="Change theme"aria-controls=theme-list aria-expanded=false aria-haspopup=true class=icon-button id=theme-toggle type=button><i class="fa fa-paint-brush"></i></button><ul aria-label=Themes class=theme-popup id=theme-list role=menu><li role=none><button class=theme id=light role=menuitem>Light (default)</button><li role=none><button class=theme id=rust role=menuitem>Rust</button><li role=none><button class=theme id=coal role=menuitem>Coal</button><li role=none><button class=theme id=navy role=menuitem>Navy</button><li role=none><button class=theme id=ayu role=menuitem>Ayu</button></ul><button aria-label="Toggle Searchbar"title="Search. (Shortkey: s)"aria-controls=searchbar aria-expanded=false aria-keyshortcuts=S class=icon-button id=search-toggle type=button><i class="fa fa-search"></i></button></div><h1 class=menu-title>Computing from the Command Line</h1><div class=right-buttons><a aria-label=Blog href=https://learnbyexample.github.io title=Blog> <i class="fa fa-home"id=home-button></i> </a><a aria-label=Twitter href=https://twitter.com/learn_byexample title=Twitter> <i class="fa fa-twitter"id=twitter-button></i> </a><a aria-label="Git repository"title="Git repository"href=https://github.com/learnbyexample/cli-computing> <i class="fa fa-github"id=git-repository-button></i> </a></div></div><div class=hidden id=search-wrapper><form class=searchbar-outer id=searchbar-outer><input placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header id=searchbar name=searchbar type=search></form><div class="searchresults-outer hidden"id=searchresults-outer><div class=searchresults-header id=searchresults-header></div><ul id=searchresults></ul></div></div><script>document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });</script><div class=content id=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=command-line-overview><a class=header href=#command-line-overview>Command Line Overview</a></h1><p>This chapter will help you take the first steps in the command line world. Apart from command examples that you can try out, you'll also learn a few essential things about working in a text environment.<p>For newbies, the sudden paradigm shift to interacting with the computer using just text commands can be overwhelming, especially for those accustomed to the graphical user interface (GUI). After regular usage, things will start to look systematic and you might realize that GUI is ill suited for repetitive tasks. With continuous use, recalling various commands will become easier. Features like command line history, aliases, tab-completion and shortcuts will help too.<p>If you've used a scientific calculator, you'd know that it is handy with too many functionalities cramped into a tiny screen and a plethora of multipurpose buttons. Command line environment is something like that, but not limited just to mathematics. From managing files to munging data, from image manipulations to working with video, you'll likely find a tool for almost any computing task you can imagine. Always remember that command line tools appeared long before graphical ones did. The rich history shows its weight in the form of robust tools and the availability of wide variety of applications.<h2 id=hello-command-line><a class=header href=#hello-command-line>Hello Command Line</a></h2><p>Open a <a href=https://en.wikipedia.org/wiki/Terminal_emulator>Terminal Emulator</a> and type the command as shown below. The <code>$</code> followed by a space character at the start is the simple command prompt that I use. It might be different for you. The actual command to type is <code>echo</code> followed by a space, then the argument <code>'Hello Command Line'</code> and finally press the <code>Enter</code> key to execute it. You should get the argument echoed back to you as the command output.<pre><code class=language-bash>$ echo 'Hello Command Line'
Hello Command Line
</code></pre><p>Here's another simple illustration. This time, the command <code>pwd</code> is entered by itself (i.e. no arguments). You should get <em>your</em> current location as the output. The <code>/</code> character separates different parts of the location (more details in the upcoming sections).<pre><code class=language-bash>$ pwd
/home/learnbyexample
</code></pre><p>Next, enter the <code>exit</code> command to quit the Terminal session.<pre><code class=language-bash>$ exit
</code></pre><p>If you are completely new to the command line world, try out the above steps a few more times until you feel comfortable with opening a Terminal Emulator, executing commands and quitting the session. More details about the command structure, customizing command prompt, etc will be discussed later.<h2 id=file-system><a class=header href=#file-system>File System</a></h2><p>In Linux, directory structure starts with the <code>/</code> symbol, which is referred to as the <strong>root</strong> directory. The <code>man hier</code> command gives description of the file system hierarchy. Here are some selected examples:<ul><li><code>/</code> This is the root directory. This is where the whole tree starts.<li><code>/bin</code> This directory contains executable programs which are needed in single user mode and to bring the system up or repair it.<li><code>/home</code> On machines with home directories for users, these are usually beneath this directory, directly or not. The structure of this directory depends on local administration decisions (optional).<li><code>/tmp</code> This directory contains temporary files which may be deleted with no notice, such as by a regular job or at system boot up.<li><code>/usr</code> This directory is usually mounted from a separate partition. It should hold only shareable, read-only data, so that it can be mounted by various machines running Linux.<li><code>/usr/bin</code> This is the primary directory for executable programs. Most programs executed by normal users which are not needed for booting or for repairing the system and which are not installed locally should be placed in this directory.<li><code>/usr/share</code> This directory contains subdirectories with specific application data, that can be shared among different architectures of the same OS.</ul><h2 id=absolute-and-relative-paths><a class=header href=#absolute-and-relative-paths>Absolute and Relative paths</a></h2><p>Quoting <a href=https://en.wikipedia.org/wiki/Path_%28computing%29#Absolute_and_relative_paths>wikipedia</a>:<blockquote><p>An <strong>absolute</strong> or <strong>full</strong> path points to the same location in a file system regardless of the current working directory. To do that, it must contain the root directory.</blockquote><blockquote><p>By contrast, a <strong>relative</strong> path starts from some given working directory, avoiding the need to provide the full absolute path. A filename can be considered as a relative path based at the current working directory. If the working directory is not the file's parent directory, a file not found error will result if the file is addressed by its name.</blockquote><p>For example, <code>/home/learnbyexample</code> is an absolute path and <code>../design</code> is a relative path. You'll learn how paths are used for performing tasks in the coming chapters.<h2 id=shells-and-terminal-emulators><a class=header href=#shells-and-terminal-emulators>Shells and Terminal Emulators</a></h2><p>These terms are often used to interchangeably mean the same thing — a prompt to allow the user to execute commands. However, they are quite different:<ul><li><strong>Shell</strong> is a command line interpreter. Sets the syntax rules for invoking commands, provides operators to connect commands and redirect data, has scripting features like loops, functions and so on<li><strong>Terminal</strong> is a text input/output environment. Responsible for visual details like font size, color, etc</ul><p>Some of the popular shells are <code>bash</code>, <code>zsh</code> and <code>fish</code>. This book will discuss only the <a href=https://en.wikipedia.org/wiki/Bash_(Unix_shell)>Bash</a> shell. Some of the popular terminal emulators are <a href=https://en.wikipedia.org/wiki/GNOME_Terminal>GNOME Terminal</a>, <a href=https://en.wikipedia.org/wiki/Konsole>konsole</a>, <a href=https://en.wikipedia.org/wiki/Xterm>xterm</a> and <a href=https://github.com/alacritty/alacritty>alacritty</a>.<p>Quoting from <a href=https://en.wikipedia.org/wiki/Unix_shell>wikipedia: Unix shell</a>:<blockquote><p>A Unix shell is a command-line interpreter or shell that provides a command line user interface for Unix-like operating systems. The shell is both an interactive command language and a scripting language, and is used by the operating system to control the execution of the system using shell scripts.<p>Users typically interact with a Unix shell using a terminal emulator; however, direct operation via serial hardware connections or Secure Shell are common for server systems. All Unix shells provide filename wildcarding, piping, here documents, command substitution, variables and control structures for condition-testing and iteration.</blockquote><p>Shell features will be discussed in later sections and chapters. For now, open a terminal and try out the following commands:<pre><code class=language-bash>$ cat /etc/shells
# /etc/shells: valid login shells
/bin/sh
/bin/dash
/bin/bash
/bin/rbash

$ echo "$SHELL"
/bin/bash
</code></pre><p>In the above example, the <code>cat</code> command is used to display the contents of a file and the <code>echo</code> command is used to display the contents of a variable. <code>SHELL</code> is an environment variable containing full path to the shell.<blockquote><p><img alt=info src=images/info.svg> The output of the above commands might be different for you. And as mentioned earlier, your command prompt might be different than <code>$ </code>. For now, you can ignore it. Or, you could type <code>PS1='$ '</code> and press the <code>Enter</code> key to set the prompt for the current session.</blockquote><p><strong>Further Reading</strong><ul><li><a href=https://unix.stackexchange.com/q/4126/109046>unix.stackexchange: What is the exact difference between a 'terminal', a 'shell', a 'tty' and a 'console'?</a><li><a href=https://en.wikipedia.org/wiki/Comparison_of_command_shells>wikipedia: Comparison of command shells</a><li><a href=https://unix.stackexchange.com/q/38175/109046>unix.stackexchange: Difference between login shell and non-login shell</a><li><a href=http://www.faqs.org/faqs/unix-faq/shell/shell-differences/>Features and differences between various shells</a><li><a href=https://hyperpolyglot.org/unix-shells>Syntax comparison on different shells with examples</a><li><a href=https://wiki.ubuntu.com/ChangingShells>Shell, choosing shell and changing default shells</a></ul><h2 id=unix-philosophy><a class=header href=#unix-philosophy>Unix Philosophy</a></h2><p>Quoting from <a href=https://en.wikipedia.org/wiki/Unix_philosophy>wikipedia: Unix Philosophy</a>:<blockquote><ul><li><p>Write programs that do one thing and do it well.</p><li><p>Write programs to work together.</p><li><p>Write programs to handle text streams, because that is a universal interface.</p></ul></blockquote><p>These principles do not strictly apply to all the command line tools, but it is good to be aware of them. As you get familiar with working from the command line, you'll be able to appreciate these guidelines better.<h2 id=command-structure><a class=header href=#command-structure>Command Structure</a></h2><p>It is not necessary to fully understand the commands used in this chapter, just the broad strokes. The examples are intended to help you get a feel for the basics of using command options and arguments.<p><strong>Command invocation without any options or arguments</strong>:<ul><li><code>clear</code> clear the terminal screen<li><code>date</code> show the current date and time</ul><p><strong>Command with options (flags)</strong>:<ul><li><code>ls -l</code> list directory contents in a long listing format<li><code>ls -la</code> list directory contents including hidden files in long listing format <ul><li>two short options <code>-l</code> and <code>-a</code> are combined together here as <code>-la</code></ul><li><code>df -h</code> report file system disk space usage sizes in human readable format<li><code>df --human-readable</code> same as <code>df -h</code> but using long option instead of short option</ul><p><strong>Command with arguments</strong>:<ul><li><code>mkdir project</code> create a directory named <code>project</code> in the current working directory<li><code>man sort</code> manual page for the <code>sort</code> command<li><code>diff file1.txt file2.txt</code> display differences between the two input files<li><code>wget https://s.ntnu.no/bashguide.pdf</code> download a file from the internet <ul><li>the link passed to <code>wget</code> in the above example is real, visit <a href=https://mywiki.wooledge.org/BashGuide>BashGuide</a> for details</ul></ul><p><strong>Command with both options and arguments</strong>:<ul><li><code>rm -r project</code> remove (delete) the <code>project</code> directory recursively<li><code>paste -sd, ip.txt</code> serialize all lines from the input file to a single line using <code>,</code> as the delimiter</ul><p><strong>Single quotes vs Double quotes</strong>:<ul><li><strong>Single quotes</strong> preserves the literal value of each character within the quotes<li><strong>Double quotes</strong> preserves the literal value of all characters within the quotes, with the exception of <code>$</code>, <code>`</code>, <code>\</code>, and, when history expansion is enabled, <code>!</code></ul><pre><code class=language-bash># no character is special within single quotes
$ echo '$SHELL'
$SHELL

# $ is special within double quotes, used to interpolate variable here
$ echo "Full path to the shell: $SHELL"
Full path to the shell: /bin/bash
</code></pre><p>More details and other types of quoting will be discussed in the <a href=./shell-features.html>Shell Features</a> chapter.<h2 id=command-network><a class=header href=#command-network>Command Network</a></h2><p>One of the <em>Unix Philosophy</em> seen earlier mentioned commands working together. The shell provides several ways to do so. A commonly used feature is redirecting the output of a command — as input of another command, to be saved in a file and so on.<ul><li>to another command <ul><li><code>du -sh * | sort -h</code> calculate size of files and folders in human-readable format using <code>du</code> and then sort them using a tool specialized for that task</ul><li>to a file <ul><li><code>grep 'pass' *.log > pass_list.txt</code> write the results to a file instead of displaying on the terminal (if the file already exists, it gets overwritten)<li><code>grep 'error' *.log >> errors.txt</code> append the results to the given file (creates a new file if necessary)</ul><li>to a variable <ul><li><code>d=$(date)</code> save command output in a variable named <code>d</code></ul></ul><p>Many more of such shell features will be discussed in later chapters.<h2 id=scripting><a class=header href=#scripting>Scripting</a></h2><p>Not all operations can be completed using a one-liner from the terminal. In such cases, you can save the instructions in a text file and then execute them. Open your favorite text editor and write the three lines shown below:<pre><code class=language-bash>$ cat cmds.sh
echo 'hello world'
echo 'how are you?'
seq 3
</code></pre><p>As an alternate to using a text editor, you can use either of the commands shown below to create this file.<pre><code class=language-bash># assuming 'echo' supports '-e' option in your environment
$ echo -e "echo 'hello world'\necho 'how are you?'\nseq 3" > cmds.sh

# a more portable solution using the builtin 'printf' command
$ printf "echo 'hello world'\necho 'how are you?'\nseq 3\n" > cmds.sh
</code></pre><p>The script file is named <code>cmds.sh</code> and has three commands in three separate lines. One way to execute the contents of this file is by using the <code>source</code> command:<pre><code class=language-bash>$ source cmds.sh
hello world
how are you?
1
2
3
</code></pre><blockquote><p><img alt=info src=./images/info.svg> Your Linux distro is likely to have an easy to use graphical text editor such as <code>gedit</code> and <code>mousepad</code>. See <a href=https://wiki.archlinux.org/title/List_of_applications#Text_editors>wiki.archlinux: text editors</a> for a huge list of editors to choose from.</blockquote><blockquote><p><img alt=info src=./images/info.svg> The <a href=./shell-scripting.html>Shell Scripting</a> chapter will discuss scripting in more detail.</blockquote><h2 id=command-help><a class=header href=#command-help>Command Help</a></h2><p>Most distros for personal use come with documentation for commands already installed. Learning how to use manuals from the terminal is handy and there are ways to get specific information as well.<h3 id=man><a class=header href=#man>man</a></h3><p>The <code>man</code> command is an interface to view manuals from within the terminal itself. This uses a <code>pager</code> (which is usually the <code>less</code> command) to display the contents. You could call these commands as terminal user interface (TUI) applications. As an example, type <code>man cat</code> and you should see something like the screenshot shown below:<p align=center><img alt="manual page for the cat command"src=images/man_cat.png><p>Since the documentation has several lines that doesn't completely fit within the terminal window, you will get only the starting part of the manual. You have several options to navigate:<ul><li><code>↑</code> and <code>↓</code> arrow keys to move up and down by a line <ul><li>you can also use <code>k</code> and <code>j</code> keys (same keys as those used in the Vim text editor)</ul><li><code>f</code> and <code>b</code> keys to move forward and backward by a screenful of content <ul><li><code>Space</code> key also moves forward by a screen</ul><li>mouse scroll moves up and down by a few lines<li><code>g</code> or <code>Home</code> go to the start of the manual<li><code>G</code> or <code>End</code> go to the end of the manual<li><code>/pattern</code> followed by <code>Enter</code> search for the given pattern in the forward direction<li><code>?pattern</code> followed by <code>Enter</code> search for the given pattern in the backward direction<li><code>n</code> go to the next match<li><code>N</code> go to the previous match<li><code>q</code> quit</ul><p>As you might have noticed in the screenshot above, you can use <code>h</code> for help about the <code>less</code> command itself. Here are some useful tips related to documentation:<ul><li><code>man man</code> gives information about the <code>man</code> command itself<li><code>man bash</code> will give you the manual page for the <code>bash</code> shell <ul><li>since this is very long, I'd recommend using the <a href=https://www.gnu.org/software/bash/manual/>online GNU Bash manual</a></ul><li><code>man find | gvim -</code> open the manual page in your favorite text editor<li><code>man -k printf</code> search the short descriptions in all the manual pages for the string <code>printf</code> <ul><li>you can also use the <code>apropos</code> command instead of <code>man -k</code></ul><li><code>wc --help</code> many commands support the <code>--help</code> option to give succinct details like options and syntax <ul><li>also, these details will be displayed on the terminal itself, no need to deal with <code>pager</code> interface</ul></ul><blockquote><p><img alt=info src=images/info.svg> See also <a href=https://unix.stackexchange.com/q/193815/109046>unix.stackexchange: How do I use man pages to learn how to use commands?</a> and <a href=https://unix.stackexchange.com/q/119/109046>unix.stackexchange: colors in man pages</a>.</blockquote><blockquote><p><img alt=info src=./images/info.svg> <img alt=info src=./images/info.svg> <img alt=info src=./images/info.svg> The Linux manual pages are usually shortened version of the full documentation. You can use the <code>info</code> command to view the complete documentation for GNU tools. <code>info</code> is also a TUI application, but with different key configuration compared to the <code>man</code> command. See <a href=https://www.gnu.org/manual/manual.html>GNU Manuals Online</a> if you'd prefer to read them from a web browser. You can also download them in formats like PDF for offline usage.</blockquote><h3 id=type><a class=header href=#type>type</a></h3><p>For certain operations, the shell provides its own set of commands, known as builtin commands. The <code>type</code> command displays information about a command like its path, whether it is a builtin, alias, function and so on.<pre><code class=language-bash>$ type cd
cd is a shell builtin
$ type sed
sed is /bin/sed
$ type type
type is a shell builtin

# multiple commands can be given as arguments
$ type pwd awk
pwd is a shell builtin
awk is /usr/bin/awk
</code></pre><p>As will be discussed in the <a href=./shell-customization.html>Shell Customization</a> chapter, you can create aliases to customize command invocations. You can use the <code>type</code> command to reveal the nature of such aliases. Here are some examples based on aliases I use:<pre><code class=language-bash>$ type p
p is aliased to 'pwd'

$ type ls
ls is aliased to 'ls --color=auto'
</code></pre><p>The <code>type</code> command formats the command output with a backtick at the start and a single quotes at the end. That doesn't play well with syntax highlighting, so I've changed the backtick to single quotes in the above illustration.<blockquote><p><img alt=info src=./images/info.svg> See also <a href=https://unix.stackexchange.com/q/11454/109046>unix.stackexchange: What is the difference between a builtin command and one that is not?</a></blockquote><h3 id=help><a class=header href=#help>help</a></h3><p>The <code>help</code> command provides documentation for builtin commands. Unlike the <code>man</code> command, the entire text is displayed as the command output. A help page in the default format is shown below. You can add <code>-m</code> option if you want the help content in a pseudo-manpage format.<pre><code class=language-bash>$ help pwd
pwd: pwd [-LP]
    Print the name of the current working directory.
    
    Options:
      -L        print the value of $PWD if it names the current working directory
      -P        print the physical directory, without any symbolic links
    
    By default, 'pwd' behaves as if '-L' were specified.
    
    Exit Status:
    Returns 0 unless an invalid option is given or the current directory
    cannot be read.
</code></pre><p>You can use the <code>-d</code> option to get a short description of the command:<pre><code class=language-bash>$ help -d compgen
compgen - Display possible completions depending on the options.
</code></pre><blockquote><p><img alt=info src=./images/info.svg> Use <code>help help</code> for documentation on the <code>help</code> command. If you use <code>help</code> without any argument, it will display all the internally defined shell commands.</blockquote><h3 id=whatis-and-whereis><a class=header href=#whatis-and-whereis>whatis and whereis</a></h3><p>Here are some more ways to get specific information about commands:<ul><li><code>whatis</code> displays one-line manual page descriptions<li><code>whereis</code> locates the binary, source, and manual page files for a command</ul><pre><code class=language-bash>$ whatis grep
grep (1)             - print lines that match patterns

$ whereis awk
awk: /usr/bin/awk /usr/lib/x86_64-linux-gnu/awk /usr/share/awk
/usr/share/man/man1/awk.1.gz
</code></pre><h3 id=ch><a class=header href=#ch>ch</a></h3><p><a href=https://explainshell.com/>explainshell</a> is a web app that shows the help text that matches each argument of the command you type in the app. For example, a screenshot for <a href=https://explainshell.com/explain?cmd=tar+-xzvf+archive.tar.gz>tar -xzvf archive.tar.gz</a> is shown below:<p align=center><img alt="explainshell example for the tar command"src=images/explainshell_tar.png><p>Inspired by this app, I wrote a <a href=https://github.com/learnbyexample/command_help>Bash script ch</a> to extract information from <code>man</code> and <code>help</code> pages. Here are some examples:<pre><code class=language-bash>$ ch ls -vX
       ls - list directory contents

       -v     natural sort of (version) numbers within text

       -X     sort alphabetically by entry extension

$ ch type -a
    type - Display information about command type.

      -a        display all locations containing an executable named NAME;
                includes aliases, builtins, and functions, if and only if
                the '-p' option is not also used
</code></pre><h3 id=further-reading><a class=header href=#further-reading>Further Reading</a></h3><ul><li><a href=https://www.mankier.com/>Linux man pages</a> — one of several websites that host man pages online<li><a href=https://wiki.archlinux.org/title/Table_of_contents>ArchWiki</a> — comprehensive documentation for Arch Linux and other distributions<li><a href=https://www.debian.org/doc/manuals/debian-reference/>Debian Reference</a> — broad overview of the Debian system, covers many aspects of system administration through shell-command examples</ul><h2 id=shortcuts-and-autocompletion><a class=header href=#shortcuts-and-autocompletion>Shortcuts and Autocompletion</a></h2><p>There are several shortcuts you can use to be productive at the command line. These will be discussed in the <a href=./shell-customization.html>Shell Customization</a> chapter. Here are some examples to give an idea:<ul><li><code>Ctrl+u</code> delete everything to the left of the cursor<li><code>Ctrl+k</code> delete from the current character to the end of the line<li><code>Ctrl+c</code> abort the currently typed command<li><code>Ctrl+l</code> clear the terminal screen and move the prompt to the top, any characters typed as part of the current command will be retained<li><code>↑</code> and <code>↓</code> arrow keys to navigate previously used commands from the history <ul><li><code>Ctrl+p</code> and <code>Ctrl+n</code> can also be used instead of arrow keys<li>you can modify the command before executing such lines from the history</ul></ul><p>The tab key helps you autocomplete commands, aliases, filenames and so on, depending on the context. If there is only one possible completion, it will be done on single tab press. Otherwise, you can press the tab key twice to get a list of possible matches (if there are any). Here's an example of completing a file path with multiple tab key presses at various stages. Not only does it saves time, it also helps to avoid typos since you are simultaneously verifying the path.<pre><code class=language-bash># pressing tab after typing '/e' will autocomplete to '/etc/'
$ ls /etc/

# pressing tab after 'di' will autocomplete to 'dict'
$ ls /etc/dict
# pressing tab twice will show all possible completions
$ ls /etc/dict
dictd/               dictionaries-common/ 

# type 'i' and press tab to get 'dictionaries-common'
$ ls /etc/dictionaries-common/

# type 'w' and press tab to get 'words'
$ ls /etc/dictionaries-common/words 
</code></pre><p>The character at which the tab key is pressed in the above example has been cherry picked for illustration purposes. The number of steps would increase if you try pressing tab after each character. With experience, using the tab key for autocompletion will become a natural part of your command line usage.<blockquote><p><img alt=info src=./images/info.svg> You can set an option to combine the features of single and double tab presses into a single tab press. This will be discussed in the <a href=./shell-customization.html>Shell Customization</a> chapter.</blockquote><h2 id=real-world-use-cases><a class=header href=#real-world-use-cases>Real world use cases</a></h2><p>If the command line environment only had file managing features, I'd still use it. Given the wide variety of applications available, I can't imagine going back to using a different GUI application for each use case. My primary work is writing ebooks, blog posts and recording videos. Here are the major CLI tools I use:<ul><li>text processing using <code>head</code>, <code>tail</code>, <code>sort</code>, <code>grep</code>, <code>sed</code>, <code>awk</code> and so on (you'll learn about these commands in later chapters)<li><a href=https://git-scm.com/>git</a> — version control<li><a href=https://github.com/jgm/pandoc/>pandoc</a> — generating PDF/EPUB book versions from markdown files<li><a href=https://github.com/rust-lang/mdBook>mdBook</a> — web version of the books from markdown files<li><a href=https://github.com/getzola/zola>zola</a> — static site generator<li><a href=https://imagemagick.org/index.php>ImageMagick</a> — image processing like resizing, adding borders, etc<li><a href=https://github.com/shssoichiro/oxipng>oxipng</a>, <a href=https://pngquant.org/>pngquant</a> and <a href=https://github.com/RazrFalcon/svgcleaner>svgcleaner</a> — optimizing images<li><a href=https://github.com/WyattBlue/auto-editor>auto-editor</a> — removing silent portions from video recordings<li><a href=https://github.com/FFmpeg/FFmpeg>FFmpeg</a> — video processing, padding for example (<code>FFmpeg</code> is also a major part of the <code>auto-editor</code> solution)</ul><p>Some of these workflows require additional management, for which I write shell functions or scripts. I do need GUI tools as well, for example, web browser, image viewer, PDF/EPUB viewers, <a href=https://github.com/MaartenBaert/ssr>SimpleScreenRecorder</a> and so on. Some of these can be handled from within the terminal too, but I prefer GUI for such cases. I do launch some of them from the terminal, primarily for providing the file or url to be opened.<p>You might wonder what advantage does the command line provide for processing images and videos? Apart from being faster, the custom parameters (like border color, border size, quality percentage, etc) are automatically saved as part of the scripts I create. After that, I can just use a single call to the script instead of waiting for a GUI application to open, navigating to required files, applying custom parameters, saving them after all the required processing is done, closing the application, etc. Also, that single script can use as many tools as needed, whereas with GUI you'll have to repeat such steps with different applications.<h2 id=exercises><a class=header href=#exercises>Exercises</a></h2><blockquote><p><img alt=info src=images/info.svg> <img alt=info src=./images/info.svg> All the exercises are also collated together in one place at <a href=https://github.com/learnbyexample/cli-computing/blob/master/exercises/exercises.md>exercises.md</a>. For solutions, see <a href=https://github.com/learnbyexample/cli-computing/blob/master/exercises/exercise-solutions.md>exercise-solutions.md</a>.</blockquote><p><strong>1)</strong> By default, is <code>echo</code> a shell builtin or external command on your system? What command could you use to get an answer for this question?<p><strong>2)</strong> What output do you get for the command shown below? Does the documentation help understand the result?<pre><code class=language-bash>$ echo apple     42 'banana     100'
</code></pre><p><strong>3)</strong> Go through <a href=https://www.gnu.org/software/bash/manual/html_node/Tilde-Expansion.html>bash manual: Tilde Expansion</a>. Is <code>~/projects</code> a relative or an absolute path? See <a href=https://unix.stackexchange.com/q/221970/109046>this unix.stackexchange thread</a> for answers.<p><strong>4)</strong> Which key would you use to get help while the <code>less</code> command is active?<p><strong>5)</strong> How would you bring the 50th line to the top of the screen while viewing a <code>man</code> page (assume <code>less</code> command is the <code>pager</code>)?<p><strong>6)</strong> What does the <code>Ctrl+k</code> shortcut do?<p><strong>7)</strong> Briefly explain the role of the following shell operators:<p><em>a)</em> <code>|</code><br> <em>b)</em> <code>></code><br> <em>c)</em> <code>>></code><p><strong>8)</strong> The <code>whatis</code> command displays one-line descriptions about commands. But it doesn't seem to work for <code>whatis type</code>. What should you use instead?<pre><code class=language-bash>$ whatis cat
cat (1)              - concatenate files and print on the standard output

$ whatis type
type: nothing appropriate.

# ???
type - Display information about command type.
</code></pre><p><strong>9)</strong> What is the role of the <code>/tmp</code> directory?<p><strong>10)</strong> Give an example each for absolute and relative paths.<p><strong>11)</strong> When would you use the <code>man -k</code> command?<p><strong>12)</strong> Are there any differences between <code>man</code> and <code>info</code> pages?</main><nav aria-label="Page navigation"class=nav-wrapper><a aria-label="Previous chapter"class="mobile-nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=introduction-setup.html rel=prev> <i class="fa fa-angle-left"></i> </a><a aria-label="Next chapter"class="mobile-nav-chapters next"title="Next chapter"aria-keyshortcuts=Right href=managing-files-directories.html rel=next> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav aria-label="Page navigation"class=nav-wide-wrapper><a aria-label="Previous chapter"class="nav-chapters previous"title="Previous chapter"aria-keyshortcuts=Left href=introduction-setup.html rel=prev> <i class="fa fa-angle-left"></i> </a><a aria-label="Next chapter"class="nav-chapters next"title="Next chapter"aria-keyshortcuts=Right href=managing-files-directories.html rel=next> <i class="fa fa-angle-right"></i> </a></nav></div><script>window.playground_copyable = true;</script><script charset=utf-8 src=elasticlunr.min.js></script><script charset=utf-8 src=mark.min.js></script><script charset=utf-8 src=searcher.js></script><script charset=utf-8 src=clipboard.min.js></script><script charset=utf-8 src=highlight.js></script><script charset=utf-8 src=book.js></script><script src=sidebar.js></script>