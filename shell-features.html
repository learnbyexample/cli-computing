<!DOCTYPE HTML><html lang=en class="sidebar-visible no-js light"><head><meta charset=UTF-8><title>Shell Features - Computing from the Command Line</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta name=description content="Linux command line and Scripting guide for beginner to intermediate users"><meta name=viewport content="width=device-width, initial-scale=1"><meta name=theme-color content=#ffffff><link rel=icon href=favicon.svg><link rel="shortcut icon"href=favicon.png><link rel=stylesheet href=css/variables.css><link rel=stylesheet href=css/general.css><link rel=stylesheet href=css/chrome.css><link rel=stylesheet href=FontAwesome/css/font-awesome.css><link rel=stylesheet href=fonts/fonts.css><link rel=stylesheet href=highlight.css><link rel=stylesheet href=tomorrow-night.css><link rel=stylesheet href=ayu-highlight.css><link rel=stylesheet href=style.css><body><script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script><script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script><script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script><script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script><nav id=sidebar class=sidebar aria-label="Table of contents"><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=preface.html>Preface</a><li class="chapter-item expanded"><a href=introduction.html><strong aria-hidden=true>1.</strong> Introduction</a><li class="chapter-item expanded"><a href=command-line-overview.html><strong aria-hidden=true>2.</strong> Command Line Overview</a><li class="chapter-item expanded"><a href=managing-files-directories.html><strong aria-hidden=true>3.</strong> Managing Files and Directories</a><li class="chapter-item expanded"><a href=shell-features.html class=active><strong aria-hidden=true>4.</strong> Shell Features</a><li class="chapter-item expanded"><a href=viewing-part-or-whole-file-contents.html><strong aria-hidden=true>5.</strong> Viewing Part or Whole File Contents</a><li class="chapter-item expanded"><a href=searching-files-and-filenames.html><strong aria-hidden=true>6.</strong> Searching Files and Filenames</a><li class="chapter-item expanded"><a href=file-properties.html><strong aria-hidden=true>7.</strong> File Properties</a><li class="chapter-item expanded"><a href=managing-processes.html><strong aria-hidden=true>8.</strong> Managing Processes</a><li class="chapter-item expanded"><a href=multipurpose-text-processing-tools.html><strong aria-hidden=true>9.</strong> Multipurpose Text Processing Tools</a><li class="chapter-item expanded"><a href=sorting-stuff.html><strong aria-hidden=true>10.</strong> Sorting Stuff</a><li class="chapter-item expanded"><a href=comparing-files.html><strong aria-hidden=true>11.</strong> Comparing Files</a><li class="chapter-item expanded"><a href=assorted-text-processing-tools.html><strong aria-hidden=true>12.</strong> Assorted Text Processing Tools</a><li class="chapter-item expanded"><a href=shell-scripting.html><strong aria-hidden=true>13.</strong> Shell Scripting</a><li class="chapter-item expanded"><a href=shell-customization.html><strong aria-hidden=true>14.</strong> Shell Customization</a></li><br><hr><li class="chapter-item expanded"><i id=git-repository-button class="fa fa-github"></i><a href=https://github.com/learnbyexample/cli-computing>   Source code</a><li class="chapter-item expanded"><i id=home-button class="fa fa-home"></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i id=book-button class="fa fa-book"></i><a href=https://learnbyexample.github.io/books/>   My Books</a><li class="chapter-item expanded"><i id=mail-button class="fa fa-envelope"></i><a href=https://learnbyexample.gumroad.com/l/learnbyexample-weekly>   learnbyexample weekly</a></ol></div><div id=sidebar-resize-handle class=sidebar-resize-handle></div></nav><div id=page-wrapper class=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div id=menu-bar class="menu-bar sticky bordered"><div class=left-buttons><button id=sidebar-toggle class=icon-button type=button title="Toggle Table of Contents"aria-label="Toggle Table of Contents"aria-controls=sidebar><i class="fa fa-bars"></i></button><button id=theme-toggle class=icon-button type=button title="Change theme"aria-label="Change theme"aria-haspopup=true aria-expanded=false aria-controls=theme-list><i class="fa fa-paint-brush"></i></button><ul id=theme-list class=theme-popup aria-label=Themes role=menu><li role=none><button role=menuitem class=theme id=light>Light (default)</button><li role=none><button role=menuitem class=theme id=rust>Rust</button><li role=none><button role=menuitem class=theme id=coal>Coal</button><li role=none><button role=menuitem class=theme id=navy>Navy</button><li role=none><button role=menuitem class=theme id=ayu>Ayu</button></ul><button id=search-toggle class=icon-button type=button title="Search. (Shortkey: s)"aria-label="Toggle Searchbar"aria-expanded=false aria-keyshortcuts=S aria-controls=searchbar><i class="fa fa-search"></i></button></div><h1 class=menu-title>Computing from the Command Line</h1><div class=right-buttons><a href=https://learnbyexample.github.io title=Blog aria-label=Blog> <i id=home-button class="fa fa-home"></i> </a><a href=https://github.com/learnbyexample/cli-computing title="Git repository"aria-label="Git repository"> <i id=git-repository-button class="fa fa-github"></i> </a></div></div><div id=search-wrapper class=hidden><form id=searchbar-outer class=searchbar-outer><input type=search id=searchbar name=searchbar placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header></form><div id=searchresults-outer class="searchresults-outer hidden"><div id=searchresults-header class=searchresults-header></div><ul id=searchresults></ul></div></div><script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script><div id=content class=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=shell-features><a class=header href=#shell-features>Shell Features</a></h1><p>This chapter will help you familiarize with some of the Bash shell features like quoting mechanisms, wildcards, redirections, command grouping, process substitution, command substitution, etc. Others will be discussed in later chapters.<blockquote><p><img src=./images/info.svg alt=info> The <a href=https://github.com/learnbyexample/cli-computing/tree/master/example_files>example_files</a> directory has the scripts and sample input files used in this chapter.</blockquote><blockquote><p><img src=./images/info.svg alt=info> Some of the examples in this chapter use commands that will be discussed in later chapters. Description of what such commands do have been added here and you'll also see more examples in the rest of the chapters.</blockquote><h2 id=quoting-mechanisms><a class=header href=#quoting-mechanisms>Quoting mechanisms</a></h2><p>This section will quote (heh) the relevant definitions from the <a href=https://www.gnu.org/software/bash/manual/bash.html#Quoting>bash manual</a> and show some examples for each of the four mechanisms.<p><strong>Escape Character</strong><blockquote><p>A non-quoted backslash <code>\</code> is the Bash escape character. It preserves the literal value of the next character that follows, with the exception of newline.<p><strong>metacharacter</strong>: A character that, when unquoted, separates words. A metacharacter is a space, tab, newline, or one of the following characters: <code>|</code>, <code>&</code>, <code>;</code>, <code>(</code>, <code>)</code>, <code><</code>, or <code>></code>.</blockquote><pre><code class=language-bash># error because ';' is a shell metacharacter
$ echo apple;cherry
apple
cherry: command not found
# using '\;' means you want to use ';' as an ordinary character
$ echo apple\;cherry
apple;cherry

# this will create two files named 'new' and 'file.txt'
$ touch new file.txt
$ ls new*txt
ls: cannot access 'new*txt': No such file or directory
$ rm new file.txt
# this will create a single file named 'new file.txt'
$ touch new\ file.txt
$ ls new*txt
'new file.txt'
$ rm new\ file.txt
</code></pre><p><strong>Single Quotes</strong><blockquote><p>Enclosing characters in single quotes (<code>'</code>) preserves the literal value of each character within the quotes. A single quote may not occur between single quotes, even when preceded by a backslash.</blockquote><p>No character is special within single quoted strings. Here's an example:<pre><code class=language-bash>$ echo 'apple;cherry'
apple;cherry
</code></pre><p>You can place strings represented by different quoting mechanisms next to each other to concatenate them together. Here's an example:<pre><code class=language-bash># concatenation of four strings
# 1: '$fruits = '
# 2: \'
# 3: 'apple and banana'
# 4: \'
$ echo '$fruits = '\''apple and banana'\'
$fruits = 'apple and banana'
</code></pre><p><strong>Double Quotes</strong><blockquote><p>Enclosing characters in double quotes (<code>"</code>) preserves the literal value of all characters within the quotes, with the exception of <code>$</code>, <code>`</code>, <code>\</code>, and, when history expansion is enabled, <code>!</code>.</blockquote><p>Here's an example showing variable interpolation within double quotes:<pre><code class=language-bash>$ qty='5'

# as seen earlier, no character is special within single quotes
$ echo 'I bought $qty apples'
I bought $qty apples

# one use of double quotes is to enable variable interpolation
$ echo "I bought $qty apples"
I bought 5 apples
</code></pre><p>Unless you specifically want the shell to interpret the contents of a variable, you should always quote the variable to avoid issues due to the presence of shell metacharacters.<pre><code class=language-bash>$ f='new file.txt'

# same as: echo 'apple banana' > new file.txt
$ echo 'apple banana' > $f
bash: $f: ambiguous redirect

# same as: echo 'apple banana' > 'new file.txt'
$ echo 'apple banana' > "$f"
$ cat "$f"
apple banana
$ rm "$f"
</code></pre><blockquote><p><img src=./images/info.svg alt=info> See also <a href=https://unix.stackexchange.com/q/131766/109046>unix.stackexchange: Why does my shell script choke on whitespace or other special characters?</a>.</blockquote><p><strong>ANSI-C Quoting</strong><blockquote><p>Words of the form <code>$'string'</code> are treated specially. The word expands to string, with backslash-escaped characters replaced as specified by the ANSI C standard.</blockquote><p>This form of quoting helps you use escape sequences like <code>\t</code> for tab, <code>\n</code> for newline and so on. You can also represent characters using their codepoint values in octal and hexademical formats.<pre><code class=language-bash>$ echo $'fig:\t42'
fig:    42

# \x27 represents single quote character in hexademical format
$ echo $'$fruits = \x27apple and banana\x27'
$fruits = 'apple and banana'

# 'grep' helps you to filter lines based on the given pattern
# but it doesn't recognize escapes like '\t' for tab characters
$ printf 'fig\t42\napple 100\nball\t20\n' | grep '\t'
# in such cases, one workaround is use to ANSI-C quoting
$ printf 'fig\t42\napple 100\nball\t20\n' | grep $'\t'
fig     42
ball    20
</code></pre><blockquote><p><img src=./images/info.svg alt=info> See <a href=https://www.gnu.org/software/bash/manual/bash.html#ANSI_002dC-Quoting>bash manual: ANSI-C Quoting</a> for complete list of supported escape sequences. See <code>man ascii</code> for a table of ASCII characters and their numerical representations.</blockquote><h2 id=wildcards><a class=header href=#wildcards>Wildcards</a></h2><p>It is relatively easy to specify complete filenames as command arguments when they are few in number. And you could use features like tab completion and middle mouse button click to assist you for such cases.<p>But what to do if you have to deal with tens and hundreds of files (or even more)? If applicable, one way is to match all the files based on a common pattern in their filenames, for example extensions like <code>.py</code>, <code>.txt</code> and so on. Wildcards (globs) will help in such cases. This feature is provided by the shell, and thus individual commands need not worry about implementing them. Pattern matching supported by wildcards are somewhat similar to regular expressions, but there are fundamental and syntactical differences too.<p>Some of the commonly used wildcards are listed below:<ul><li><code>*</code> match any character, zero or more times <ul><li>as a special case, <code>*</code> won't match the starting <code>.</code> of hidden files unless the <code>dotglob</code> shell option is set</ul><li><code>?</code> match any character exactly once<li><code>[set]</code> match any of these characters once<li><code>[^set]</code> match any characters <em>except</em> the given set of characters <ul><li>you can also use <code>[!set]</code> to negate the character class</ul><li><code>[a-z]</code> match a range of characters from <code>a</code> to <code>z</code><li><code>[0-9a-fA-F]</code> match any hexademical character</ul><p>And here are some examples:<pre><code class=language-bash># change to the 'scripts' directory and source the 'globs.sh' script
$ source globs.sh
$ ls
100.sh   f1.txt      f4.txt    hi.sh   math.h         report-02.log
42.txt   f2_old.txt  f7.txt    ip.txt  notes.txt      report-04.log
calc.py  f2.txt      hello.py  main.c  report-00.log  report-98.log

# beginning with 'c' or 'h' or 't'
$ ls [cht]*
calc.py  hello.py  hi.sh

# only hidden files and directories
$ ls -d .*
.  ..  .hidden  .somerc

# ending with '.c' or '.py'
$ ls *.c *.py
calc.py  hello.py  main.c

# containing 'o' as well as 'x' or 'y' or 'z' afterwards
$ ls *o*[xyz]*
f2_old.txt  hello.py  notes.txt

# ending with '.' and two more characters
$ ls *.??
100.sh  calc.py  hello.py  hi.sh

# ending with '.txt' but not starting with 'f'
$ ls [^f]*.txt
42.txt  ip.txt  notes.txt

# containing digits '1' to '5' and ending with 'log'
$ ls *[1-5]*log
report-02.log  report-04.log
</code></pre><p>Since some characters are special inside the character class, you need to arrange them differently to treat them as ordinary characters:<ul><li><code>-</code> should be the first or the last character in the set<li><code>^</code> should be other than the first character<li><code>]</code> should be the first character</ul><pre><code class=language-bash>$ ls *[ns-]*
100.sh  main.c     report-00.log  report-04.log
hi.sh   notes.txt  report-02.log  report-98.log

$ touch 'a^b' 'mars[planet].txt'
$ rm -i *[]^]*
rm: remove regular empty file 'a^b'? y
rm: remove regular empty file 'mars[planet].txt'? y
</code></pre><p>A <strong>named character set</strong> is defined by a name enclosed between <code>[:</code> and <code>:]</code> and has to be used within a character class <code>[]</code>, along with any other characters as needed.<table><thead><tr><th>Named set<th>Description<tbody><tr><td><code>[:digit:]</code><td><code>[0-9]</code><tr><td><code>[:lower:]</code><td><code>[a-z]</code><tr><td><code>[:upper:]</code><td><code>[A-Z]</code><tr><td><code>[:alpha:]</code><td><code>[a-zA-Z]</code><tr><td><code>[:alnum:]</code><td><code>[0-9a-zA-Z]</code><tr><td><code>[:word:]</code><td><code>[0-9a-zA-Z_]</code><tr><td><code>[:xdigit:]</code><td><code>[0-9a-fA-F]</code><tr><td><code>[:cntrl:]</code><td>control characters — first 32 ASCII characters and 127th (DEL)<tr><td><code>[:punct:]</code><td>all the punctuation characters<tr><td><code>[:graph:]</code><td><code>[:alnum:]</code> and <code>[:punct:]</code><tr><td><code>[:print:]</code><td><code>[:alnum:]</code>, <code>[:punct:]</code> and space<tr><td><code>[:ascii:]</code><td>all the ASCII characters<tr><td><code>[:blank:]</code><td>space and tab characters<tr><td><code>[:space:]</code><td>whitespace characters</table><pre><code class=language-bash># starting with a digit character or 'c'
# same as: [0-9c]*
$ ls [[:digit:]c]*
100.sh  42.txt  calc.py

# starting with a non-alphabet character
$ ls [^[:alpha:]]*
100.sh  42.txt
</code></pre><blockquote><p><img src=images/info.svg alt=info> You can use <code>echo</code> to test how the wildcards will expand before using a command to act upon the matching files. For example, <code>echo *.txt</code> before using commands like <code>rm *.txt</code>. One difference compared to <code>ls</code> is that <code>echo</code> will display the wildcard as is instead of showing an error if there's no match.</blockquote><blockquote><p><img src=./images/info.svg alt=info> See <a href=https://www.gnu.org/software/bash/manual/bash.html#Pattern-Matching>bash manual: Pattern Matching</a> for more details, information on locale stuff and so on.</blockquote><h2 id=brace-expansion><a class=header href=#brace-expansion>Brace Expansion</a></h2><p>This is not a wildcard feature, you just get expanded strings. Brace expansion has two mechanisms for reducing typing:<ul><li>taking out common portions among multiple strings<li>generating a range of characters</ul><p>Say you want to create two files named <code>test_x.txt</code> and <code>test_y.txt</code>. These two strings have something in common at the start and the end. You can specify the unique portions as comma separated strings within a pair of curly braces and use the common parts around the braces. Multiple braces can be used as needed. Use <code>echo</code> for testing purposes.<pre><code class=language-bash>$ mkdir practice_brace
$ cd practice_brace

# same as: touch ip1.txt ip3.txt ip7.txt
$ touch ip{1,3,7}.txt
$ ls ip*txt
ip1.txt  ip3.txt  ip7.txt

# same as: mv ip1.txt ip_a.txt
$ mv ip{1,_a}.txt
$ ls ip*txt
ip3.txt  ip7.txt  ip_a.txt

$ echo adders/{half,full}_adder.v
adders/half_adder.v adders/full_adder.v

$ echo file{0,1}.{txt,log}
file0.txt file0.log file1.txt file1.log

# you can also have an empty alternate
$ echo file{,1}.txt
file.txt file1.txt

# example with nested braces
$ echo file.{txt,log{,.bkp}}
file.txt file.log file.log.bkp
</code></pre><p>To generate a range, specify numbers or single characters separated by <code>..</code> and an optional third argument as the step value. Here are some examples:<pre><code class=language-bash>$ echo {1..4}
1 2 3 4
$ echo {4..1}
4 3 2 1

$ echo {1..2}{a..b}
1a 1b 2a 2b

$ echo file{1..4}.txt
file1.txt file2.txt file3.txt file4.txt

$ echo file{1..10..2}.txt
file1.txt file3.txt file5.txt file7.txt file9.txt

$ echo file_{x..z}.txt
file_x.txt file_y.txt file_z.txt

$ echo {z..j..-3}
z w t q n k

# '0' prefix
$ echo {008..10}
008 009 010
</code></pre><p>If the use of braces doesn't match the expansion syntax, it will be left as is:<pre><code class=language-bash>$ echo file{1}.txt
file{1}.txt

$ echo file{1-4}.txt
file{1-4}.txt
</code></pre><h2 id=extended-and-recursive-globs><a class=header href=#extended-and-recursive-globs>Extended and Recursive globs</a></h2><p>From <code>man bash</code>:<table><thead><tr><th>Extended glob<th>Description<tbody><tr><td><code>?(pattern-list)</code><td>Matches zero or one occurrence of the given patterns<tr><td><code>*(pattern-list)</code><td>Matches zero or more occurrences of the given patterns<tr><td><code>+(pattern-list)</code><td>Matches one or more occurrences of the given patterns<tr><td><code>@(pattern-list)</code><td>Matches one of the given patterns<tr><td><code>!(pattern-list)</code><td>Matches anything except one of the given patterns</table><p>Extended globs are disabled by default. You can use the <code>shopt</code> builtin to set/unset shell options like <code>extglob</code>, <code>globstar</code>, etc. You can also check what is the current status of such options.<pre><code class=language-bash>$ shopt extglob 
extglob         off

# set extglob
$ shopt -s extglob 
$ shopt extglob 
extglob         on

# unset extglob
$ shopt -u extglob 
$ shopt extglob 
extglob         off
</code></pre><p>Here are some examples, assuming <code>extglob</code> option has already been set:<pre><code class=language-bash># change to the 'scripts' directory and source the 'globs.sh' script
$ source globs.sh
$ ls
100.sh   f1.txt      f4.txt    hi.sh   math.h         report-02.log
42.txt   f2_old.txt  f7.txt    ip.txt  notes.txt      report-04.log
calc.py  f2.txt      hello.py  main.c  report-00.log  report-98.log

# one or more digits followed by '.' and then zero or more characters
$ ls +([0-9]).*
100.sh  42.txt

# same as: ls *.c *.h
$ ls @(*.c|*.h)
main.c  math.h

# not ending with '.txt'
$ ls !(*.txt)
100.sh   hello.py  main.c  report-00.log  report-04.log
calc.py  hi.sh     math.h  report-02.log  report-98.log

# not ending with '.txt' or '.log'
$ ls *.!(txt|log)
100.sh  calc.py  hello.py  hi.sh  main.c  math.h
</code></pre><p>If you enable the <code>globstar</code> option, you can recursively match filenames within a specified path.<pre><code class=language-bash># change to the 'scripts' directory and source the 'ls.sh' script
$ source ls.sh

# with 'find' command (this will be explained in a later chapter)
$ find -name '*.txt'
./todos/books.txt
./todos/outing.txt
./ip.txt

# with 'globstar' enabled
$ shopt -s globstar
$ ls **/*.txt
ip.txt  todos/books.txt  todos/outing.txt

# another example
$ ls -1 **/*.@(py|sh)
hello_world.py
projects/calculator/calc.sh
projects/tictactoe/game.py
</code></pre><blockquote><p><img src=images/info.svg alt=info> Add the <code>shopt</code> invocations to <code>~/.bashrc</code> if you want these settings applied at terminal startup. This will be discussed in more detail later.</blockquote><h2 id=set><a class=header href=#set>set</a></h2><p>The <code>set</code> builtin command helps you to set or unset values of shell options and positional parameters. Here are some examples for shell options:<pre><code class=language-bash># disables logging command history from this point onwards
$ set +o history
# enable history logging
$ set -o history

# use vi-style CLI editing interface
$ set -o vi
# use emancs-style interface, this is usually the default
$ set -o emacs
</code></pre><p>You'll see more examples (for example, <code>set -x</code>) in later chapters. See <a href=https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin>bash manual: Set Builtin</a> for documentation.<h2 id=pipelines><a class=header href=#pipelines>Pipelines</a></h2><p>The pipe control operator <code>|</code> helps you connect the output of a command as the input of another command. This operator vastly reduces the need for temporary intermediate files. As discussed previously in the "Unix Philosophy" section, command line tools specialize in one task. If you can break down a problem into smaller tasks, the pipe operator will come in handy often. Here are some examples:<pre><code class=language-bash># change to the 'scripts' directory and source the 'du.sh' script
$ source du.sh

# list of files
$ ls
projects  report.log  todos
# count the number of files
# you can also use: printf '%q\n' * | wc -l
$ ls -q | wc -l
3

# report size of files/folders in human readable format
# and then sort them based on human readable sizes in ascending order
$ du -sh * | sort -h
8.0K    todos
48K     projects
7.4M    report.log
</code></pre><p>In the above examples, <code>ls</code> and <code>du</code> perform their own tasks of displaying list of files and showing file sizes respectively. After that, the <code>wc</code> and <code>sort</code> commands take care of calculating number of lines and sorting respectively. In such cases, the pipe operator saves you the trouble of dealing with temporary data.<blockquote><p><img src=./images/info.svg alt=info> The <code>|&</code> control operator will be discussed later in this chapter.</blockquote><h3 id=tee><a class=header href=#tee>tee</a></h3><p>Sometimes, you might want to display the command output on the terminal as well as require the results for later use. In such cases, you can use the <code>tee</code> command:<pre><code class=language-bash>$ du -sh * | tee sizes.log
48K     projects
7.4M    report.log
8.0K    todos

$ cat sizes.log
48K     projects
7.4M    report.log
8.0K    todos

$ rm sizes.log
</code></pre><h2 id=redirection><a class=header href=#redirection>Redirection</a></h2><p>From <a href=https://www.gnu.org/software/bash/manual/bash.html#Redirections>bash manual: Redirections</a>:<blockquote><p>Before a command is executed, its input and output may be <em>redirected</em> using a special notation interpreted by the shell. Redirection allows commands' file handles to be duplicated, opened, closed, made to refer to different files, and can change the files the command reads from and writes to. Redirection may also be used to modify file handles in the current shell execution environment.</blockquote><p>There are three standard data streams:<ul><li><strong>standard input</strong> (<code>stdin</code> — file descriptor 0)<li><strong>standard output</strong> (<code>stdout</code> — file descriptor 1)<li><strong>standard error</strong> (<code>stderr</code> — file descriptor 2)</ul><p>Both standard output and error are displayed on the terminal by default. The <code>stderr</code> stream is used when something goes wrong with the command usage. Each of these three streams have a predefined file descriptor as mentioned above. In this section, you'll see how to redirect these three streams.<blockquote><p><img src=./images/info.svg alt=info> Redirections can be placed anywhere, but usually used at the start or end of a command. For example, the following two commands are equivalent:<pre><code class=language-bash>>op.txt grep 'error' report.log

grep 'error' report.log >op.txt
</code></pre></blockquote><blockquote><p><img src=images/info.svg alt=info> Space characters between the redirection operators and the filename are optional.</blockquote><h3 id=redirecting-output><a class=header href=#redirecting-output>Redirecting output</a></h3><p>You can use the <code>></code> operator to redirect the standard output of a command to a file. A number prefix can be added to the <code>></code> operator to work with that particular file descriptor. Default is <code>1</code> (recall that the file descriptor for <code>stdout</code> is <code>1</code>), so <code>1></code> and <code>></code> perform the same operation. Use <code>>></code> to append the output to a file.<p>The filename provided to the <code>></code> and <code>>></code> operators will be created if a regular file of that name doesn't exist yet. If the file already exists, <code>></code> will overwrite that file and <code>>></code> will append contents to that file.<pre><code class=language-bash># change to the 'example_files/text_files' directory for this section

# save first three lines of 'sample.txt' to 'op.txt'
$ head -n3 sample.txt > op.txt
$ cat op.txt
 1) Hello World
 2) 
 3) Hi there

# append last two lines of 'sample.txt' to 'op.txt'
$ tail -n2 sample.txt >> op.txt
$ cat op.txt
 1) Hello World
 2) 
 3) Hi there
14) He he he
15) Adios amigo

$ rm op.txt
</code></pre><blockquote><p><img src=./images/info.svg alt=info> You can use <code>/dev/null</code> as a filename to discard the output, to provide an empty file for a command, etc.</blockquote><blockquote><p><img src=images/info.svg alt=info> Use <code>set noclobber</code> to prevent overwriting if a file already exists. When the <code>noclobber</code> option is set, you can still overwrite a file by using <code>>|</code> instead of the <code>></code> operator.</blockquote><h3 id=redirecting-input><a class=header href=#redirecting-input>Redirecting input</a></h3><p>Some commands like <code>tr</code> and <code>datamash</code> can only work with data from the standard input. This isn't an issue when you are piping data from another command, for example:<pre><code class=language-bash># filter lines containing 'the' from the input file 'greeting.txt'
# and then display the results in uppercase using the 'tr' command
$ grep 'the' greeting.txt | tr 'a-z' 'A-Z'
HI THERE
</code></pre><p>You can use the <code><</code> redirection operator if you want to pass data from a file to such commands. The default prefix here is <code>0</code>, which is the file descriptor for <code>stdin</code> data. Here's an example:<pre><code class=language-bash>$ tr 'a-z' 'A-Z' &LTgreeting.txt
HI THERE
HAVE A NICE DAY
</code></pre><p>In some cases, a tool behaves differently when processing <code>stdin</code> data compared to file input. Here's an example with <code>wc -l</code> to report the total number of lines in the input:<pre><code class=language-bash># line count, filename is part of the output as well
$ wc -l purchases.txt
8 purchases.txt

# filename won't be part of the output for stdin data
# helpful for assigning the number to a variable for scripting purposes
$ wc -l &LTpurchases.txt
8
</code></pre><p>Sometimes, you need to pass <code>stdin</code> data as well as other file inputs to a command. In such cases, you can use <code>-</code> to represent data from standard input. Here's an example:<pre><code class=language-bash>$ cat scores.csv
Name,Maths,Physics,Chemistry
Ith,100,100,100
Cy,97,98,95
Lin,78,83,80

# insert a column at the start
$ printf 'ID\n1\n2\n3' | paste -d, - scores.csv
ID,Name,Maths,Physics,Chemistry
1,Ith,100,100,100
2,Cy,97,98,95
3,Lin,78,83,80
</code></pre><p>Even though a command accepts file input directly as an argument, redirecting can help for interactive usage. Here's an example:<pre><code class=language-bash># display only the third field
$ &LTscores.csv cut -d, -f3
Physics
100
98
83

# later, you realize that you need the first field too
# use 'up' arrow key to bring the previous command
# and modify the argument easily at the end
# if you had used cut -d, -f3 scores.csv instead,
# you'd have to navigate past the filename to modify the argument
$ &LTscores.csv cut -d, -f1,3
Name,Physics
Ith,100
Cy,98
Lin,83
</code></pre><blockquote><p><img src=./images/info.svg alt=info> <img src=./images/warning.svg alt=warning> Don't use <code>cat filename | cmd</code> for passing file content as <code>stdin</code> data, unless you need to concatenate data from multiple input files. See <a href=https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat>wikipedia: UUOC</a> and <a href=https://porkmail.org/era/unix/award.html>Useless Use of Cat Award</a> for more details.</blockquote><h3 id=redirecting-error><a class=header href=#redirecting-error>Redirecting error</a></h3><p>Recall that the file descriptor for <code>stderr</code> is <code>2</code>. So, you can use <code>2></code> to redirect standard error to a file. Use <code>2>></code> if you need to append the contents. Here's an example:<pre><code class=language-bash># assume 'abcdxyz' doesn't exist as a shell command
$ abcdxyz
abcdxyz: command not found

# the error in such cases will be part of the stderr stream, not stdout
# so, you'll need to use 2> here
$ abcdxyz 2> cmderror.log

$ cat cmderror.log
abcdxyz: command not found

$ rm cmderror.log
</code></pre><blockquote><p><img src=./images/info.svg alt=info> As mentioned earlier, you can use <code>/dev/null</code> as a filename if you need to just discard the results.</blockquote><h3 id=combining-stdout-and-stderr><a class=header href=#combining-stdout-and-stderr>Combining stdout and stderr</a></h3><p>Newer versions of <code>bash</code> provide these handy shortcuts:<ul><li><code>&></code> redirect both <code>stdout</code> and <code>stderr</code> (overwrites an existing file)<li><code>&>></code> redirect both <code>stdout</code> and <code>stderr</code> (appends to existing file)<li><code>|&</code> pipe both <code>stdout</code> and <code>stderr</code> as input to another command</ul><p>Here's an example, which assumes <code>xyz.txt</code> doesn't exist, thus leading to errors:<pre><code class=language-bash># using '>' will redirect only the stdout stream
# stderr will be displayed on the terminal
$ grep 'log' file_size.txt xyz.txt > op.txt
grep: xyz.txt: No such file or directory

# using '&>' will redirect both the stdout and stderr streams
$ grep 'log' file_size.txt xyz.txt &> op.txt
$ cat op.txt
file_size.txt:104K    power.log
file_size.txt:746K    report.log
grep: xyz.txt: No such file or directory

$ rm op.txt
</code></pre><p>And here's an example with the <code>|&</code> operator:<pre><code class=language-bash># filter lines containing 'log' from the given file arguments
# and then filter lines containing 'or' from the combined stdout and stderr
$ grep 'log' file_size.txt xyz.txt |& grep 'or'
file_size.txt:746K    report.log
grep: xyz.txt: No such file or directory
</code></pre><p>For earlier Bash versions, you'll have to manually redirect the streams:<ul><li><code>1>&2</code> redirects file descriptor <code>1</code> (<code>stdout</code>) to the file descriptor <code>2</code> (<code>stderr</code>)<li><code>2>&1</code> redirects file descriptor <code>2</code> (<code>stderr</code>) to the file descriptor <code>1</code> (<code>stdout</code>)</ul><p>Here are some examples:<pre><code class=language-bash># note that the order of redirections is important here
# you can also use: 2> op.txt 1>&2
$ grep 'log' file_size.txt xyz.txt > op.txt 2>&1
$ cat op.txt
file_size.txt:104K    power.log
file_size.txt:746K    report.log
grep: xyz.txt: No such file or directory
$ rm op.txt

$ grep 'log' file_size.txt xyz.txt 2>&1 | grep 'or'
file_size.txt:746K    report.log
grep: xyz.txt: No such file or directory
</code></pre><h3 id=waiting-for-stdin><a class=header href=#waiting-for-stdin>Waiting for stdin</a></h3><p>Sometimes, you might mistype a command without providing input. And instead of getting an error, you'll see the cursor patiently waiting for something. This isn't the shell hanging up on you. The command is waiting for you to type data, so that it can perform its task.<p>Say, you typed <code>cat</code> and pressed the Enter key. Seeing the blinking cursor, you type some text and press the Enter key again. You'll see the text you just typed echoed back to you as <code>stdout</code> (which is the functionality of the <code>cat</code> command). This will continue again and again, until you tell the shell that you are done. How to do that? Press <code>Ctrl+d</code> on a fresh line or press <code>Ctrl+d</code> twice at the end of a line. In the latter case, you'll not get a newline character at the end of the data.<pre><code class=language-bash># press Enter key and Ctrl+d after typing all the required characters
$ cat
knock knock
knock knock
anybody here?
anybody here?

# 'tr' command here translates lowercase to uppercase
$ tr 'a-z' 'A-Z'
knock knock 
KNOCK KNOCK
anybody here?
ANYBODY HERE?
</code></pre><blockquote><p><img src=./images/info.svg alt=info> Getting output immediately after each input line depends on the command's functionality. Commands like <code>sort</code> and <code>shuf</code> will wait for the entire input data before producing the output.<pre><code class=language-bash># press Ctrl+d after the line containing 'bee'
$ sort
lion
zebra
bee
bee
lion
zebra
</code></pre></blockquote><p>Here's an example with output redirection:<pre><code class=language-bash>> # press Ctrl+d after the line containing 'histogram'
# filter lines containing 'is'
$ grep 'is' > op.txt
hi there
this is a sample line
have a nice day
histogram

$ cat op.txt
this is a sample line
histogram

$ rm op.txt
</code></pre><blockquote><p><img src=./images/info.svg alt=info> See also <a href=https://unix.stackexchange.com/q/16333/109046>unix.stackexchange: difference between Ctrl+c and Ctrl+d</a>.</blockquote><h3 id=here-documents><a class=header href=#here-documents>Here Documents</a></h3><p>Here Documents is another way to provide <code>stdin</code> data. In this case, the termination condition is a line matching a predefined string which is specified after the <code><<</code> redirection operator. This is especially helpful in shell scripts, since pressing <code>Ctrl+d</code> interactively won't be possible. Here's an example:<pre><code class=language-bash># > and a space at the start of lines are only present in interactive mode
# don't type them in a shell script
# EOF is typically used as the special string
$ cat << 'EOF' > fruits.txt
> banana 2
> papaya 3
> mango  10
> EOF

$ cat fruits.txt
banana 2
papaya 3
mango  10
$ rm fruits.txt
</code></pre><p>In the above example, the termination string was enclosed in single quotes to prevent parameter expansion, command substitution, etc. You can also use <code>\string</code> for this purpose. If you use <code><&LT-</code> instead of <code><<</code>, leading tab characters can be added at the start of input lines without being part of the actual data.<blockquote><p><img src=./images/info.svg alt=info> See <a href=https://www.gnu.org/software/bash/manual/bash.html#Here-Documents>bash manual: Here Documents</a> and <a href=https://stackoverflow.com/q/2953081/4082052>stackoverflow: here documents</a> for more examples and details.</blockquote><h3 id=here-strings><a class=header href=#here-strings>Here Strings</a></h3><p>This is similar to Here Documents, but the termination string isn't used. The redirection operator is <code><<<</code>. Here are some examples:<pre><code class=language-bash>$ tr 'a-z' 'A-Z' <<< hello
HELLO
$ tr 'a-z' 'A-Z' <<< 'hello world'
HELLO WORLD

$ greeting='hello world'
$ tr 'a-z' 'A-Z' > op.txt <<< "$greeting"
$ cat op.txt
HELLO WORLD
$ rm op.txt
</code></pre><h3 id=further-reading><a class=header href=#further-reading>Further Reading</a></h3><ul><li><a href=https://mywiki.wooledge.org/BashGuide/InputAndOutput#Redirection>Short introduction to shell redirection</a><li><a href=https://wiki.bash-hackers.org/howto/redirection_tutorial>Illustrated Redirection Tutorial</a><li><a href=https://stackoverflow.com/q/818255/4082052>Redirect a stream to another file descriptor using >&</a><li><a href=https://mywiki.wooledge.org/BashFAQ/055>Difference between 2>&1 >foo and >foo 2>&1</a><li><a href=https://stackoverflow.com/q/876239/4082052>Redirect and append both stdout and stderr to a file</a></ul><h2 id=grouping-commands><a class=header href=#grouping-commands>Grouping commands</a></h2><p>You can use <code>(list)</code> and <code>{ list; }</code> compound commands to redirect content for several commands. The former is executed in a subshell whereas the latter is executed in the current shell context. Spaces around <code>()</code> are optional but necessary for the <code>{}</code> version. From <a href=https://www.gnu.org/software/bash/manual/bash.html#Lists>bash manual: Lists of Commands</a>:<blockquote><p>A <code>list</code> is a sequence of one or more pipelines separated by one of the operators <code>;</code>, <code>&</code>, <code>&&</code>, or <code>||</code>, and optionally terminated by one of <code>;</code>, <code>&</code>, or a newline.</blockquote><p>Here are some examples of command groupings:<pre><code class=language-bash># change to the 'example_files/text_files' directory for this section

# the 'sed' command here gives the first line of the input
# rest of the lines are then processed by the 'sort' command
# thus, the header will always be the first line in the output
$ (sed -u '1q' ; sort) < scores.csv
Name,Maths,Physics,Chemistry
Cy,97,98,95
Ith,100,100,100
Lin,78,83,80

# save first three and last two lines from 'sample.txt' to 'op.txt'
$ { head -n3 sample.txt; tail -n2 sample.txt; } > op.txt
$ cat op.txt
 1) Hello World
 2) 
 3) Hi there
14) He he he
15) Adios amigo
$ rm op.txt
</code></pre><p>You might wonder why the second command did not use <code>< sample.txt</code> instead of repeating the filename twice. The reason is that some commands might read more than what is required (for example, buffering) and thus cause issues for the remaining commands. In the <code>sed+sort</code> example, the <code>-u</code> option guarantees not to read more than the required data. See <a href=https://unix.stackexchange.com/q/11856/109046>unix.stackexchange: sort but keep header line at the top</a> for more examples and details.<blockquote><p><img src=./images/info.svg alt=info> You don't need the <code>()</code> or <code>{}</code> groups to see the results of multiple commands on the terminal. Just the <code>;</code> separator between the commands would be enough. See also <a href=https://www.gnu.org/software/bash/manual/bash.html#Command-Execution-Environment>bash manual: Command Execution Environment</a>.<pre><code class=language-bash>$ head -n1 sample.txt ; echo 'have a nice day'
 1) Hello World
have a nice day
</code></pre></blockquote><h2 id=list-control-operators><a class=header href=#list-control-operators>List control operators</a></h2><p>You can use these operators to control the execution of the subsequent command depending on the exit status of the first command. From <a href=https://www.gnu.org/software/bash/manual/bash.html#Lists>bash manual: Lists of Commands</a>:<blockquote><p>AND and OR lists are sequences of one or more pipelines separated by the control operators <code>&&</code> and <code>||</code>, respectively. AND and OR lists are executed with left associativity.</blockquote><p>For AND list, the second command will be executed if and only if the first command exits with <code>0</code> status.<pre><code class=language-bash># first command succeeds here, so the second command is also executed
$ echo 'hello' && echo 'have a nice day'
hello
have a nice day

# assume 'abcdxyz' doesn't exist as a shell command
# the second command will not be executed
$ abcdxyz && echo 'have a nice day'
abcdxyz: command not found

# if you use ';' instead, the second command will still be executed
$ abcdxyz ; echo 'have a nice day'
abcdxyz: command not found
have a nice day
</code></pre><p>For OR list, the second command will be executed if and only if the first command does <em>not</em> exit with <code>0</code> status.<pre><code class=language-bash># since the first command succeeds, the second one won't run
$ echo 'hello' || echo 'have a nice day'
hello

# assume 'abcdxyz' doesn't exist as a shell command
# since the first command fails, the second one will run
$ abcdxyz || echo 'have a nice day'
abcdxyz: command not found
have a nice day
</code></pre><h2 id=command-substitution><a class=header href=#command-substitution>Command substitution</a></h2><p>Command substitution allows you to use the standard output of a command as part of another command. Trailing newlines, if any, will be removed. You can use the newer and preferred syntax <code>$(command)</code> or the older syntax <code>`command`</code>. Here are some examples:<pre><code class=language-bash># sample input
$ printf 'hello\ntoday is: \n'
hello
today is:
# append output from the 'date' command to the line containing 'today'
$ printf 'hello\ntoday is: \n' | sed '/today/ s/$/'"$(date +%A)"'/'
hello
today is: Monday

# save the output of 'wc' command to a variable
# same as: line_count=`wc -l &LTsample.txt`
$ line_count=$(wc -l &LTsample.txt)
$ echo "$line_count"
15
</code></pre><p>Here's an example with nested substitutions:<pre><code class=language-bash># dirname removes the trailing path component
$ dirname projects/tictactoe/game.py
projects/tictactoe
# basename removes the leading directory component
$ basename projects/tictactoe
tictactoe

$ proj=$(basename $(dirname projects/tictactoe/game.py))
$ echo "$proj"
tictactoe
</code></pre><p>Difference between the two types of syntax is quoted below from <a href=https://www.gnu.org/software/bash/manual/bash.html#Command-Substitution>bash manual: Command Substitution</a>:<blockquote><p>When the old-style backquote form of substitution is used, backslash retains its literal meaning except when followed by <code>$</code>, <code>`</code>, or <code>\</code>. The first backquote not preceded by a backslash terminates the command substitution. When using the $(command) form, all characters between the parentheses make up the command; none are treated specially.<p>Command substitutions may be nested. To nest when using the backquoted form, escape the inner backquotes with backslashes.</blockquote><h2 id=process-substitution><a class=header href=#process-substitution>Process substitution</a></h2><p>You can redirect output of commands to take the place of a file argument with process substitution using the <code><(list)</code> syntax. The shell will take care of passing a filename with the standard output of those commands. Here's an example:<pre><code class=language-bash># change to the 'example_files/text_files' directory for this section

$ cat scores.csv
Name,Maths,Physics,Chemistry
Ith,100,100,100
Cy,97,98,95
Lin,78,83,80

# can also use: paste -d, <(echo 'ID'; seq 3) scores.csv
$ paste -d, <(printf 'ID\n1\n2\n3') scores.csv 
ID,Name,Maths,Physics,Chemistry
1,Ith,100,100,100
2,Cy,97,98,95
3,Lin,78,83,80
</code></pre><p>For the above example, you could also have used <code>-</code> to represent <code>stdin</code> piped data as seen in an earlier section. Here's an example where two substitutions are used. This essentially helps you to avoid managing multiple temporary files, similar to how the <code>|</code> pipe operator helps for single temporary file use case.<pre><code class=language-bash># side-by-side view of sample input files
$ paste f1.txt f2.txt
1       1
2       hello
3       3
world   4

# this command gives the common lines between two files
# the files have to be sorted for the command to work properly
$ comm -12 <(sort f1.txt) <(sort f2.txt)
1
3
</code></pre><blockquote><p><img src=./images/info.svg alt=info> See <a href=https://unix.stackexchange.com/q/609375/109046>this unix.stackexchange thread</a> for examples with <code>>(list)</code> form.</blockquote></main><nav class=nav-wrapper aria-label="Page navigation"><a rel=prev href=managing-files-directories.html class="mobile-nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=viewing-part-or-whole-file-contents.html class="mobile-nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav class=nav-wide-wrapper aria-label="Page navigation"><a rel=prev href=managing-files-directories.html class="nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=viewing-part-or-whole-file-contents.html class="nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a></nav></div><script>
            window.playground_copyable = true;
        </script><script src=elasticlunr.min.js charset=utf-8></script><script src=mark.min.js charset=utf-8></script><script src=searcher.js charset=utf-8></script><script src=clipboard.min.js charset=utf-8></script><script src=highlight.js charset=utf-8></script><script src=book.js charset=utf-8></script><script src=sidebar.js></script>